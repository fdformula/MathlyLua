<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<style>
a { text-decoration: none; }
p { margin: 20px }
div { font-size: 16px; margin: 30px 20px }
table, pre { margin: 1px 25px }
</style>
</head>
<body>
<div>
<h2><a name=top></a><a href=#mathly>Mathly Turns Lua into a Tiny but Powerful MATLAB</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &rArr; <a href=lua5_4.html>Lua 5.4 Manual</a></h2>

<p>Mathly for <a href=https://www.lua.org>Lua</a> is a Lua module which turns Lua into a tiny but powerful MATLAB. It provides a group of commonly used MATLAB functions and features,
for example, <code>linspace</code>, <code>zeros</code>, <code>rand</code>, <code>save</code>, convenient matrix operations, and even
<code>plot</code>. They make coding and testing a thought/algorithm much easier and faster than working in most other
programming languages. If there is anything many love the most about MATLAB, these tools are.</p>

<p>Mathly for Lua requires a small Lua module, plotly.lua (see <a href="https://github.com/kenloen/plotly.lua">https://github.com/kenloen/plotly.lua</a>).
The latter is modified to meet the needs of mathly, and it requires another Lua module, dkjson.lua
(see <a href="http://dkolf.de/dkjson-lua">http://dkolf.de/dkjson-lua</a>).</p>

<p>Mathly uses Plotly JavaScript graphing tools (see <a href="https://plotly.com/javascript/">https://plotly.com/javascript/</a>)
to plot graphs of single-variable functions. Therefore, graphs are shown in an internet browser.</p>

<p>The entire mathly tool together with Lua is less than 5 MB, while providing enough features for instructors and
college students to introduce and/or implement many numerical algorithms. Because it is super lightweight and fast as well,
it can be employed to slow devices like old Microsoft Surface Pro 4. Imagine that the smallest size of GNU Octave
is about 300 MB, MATLAB needs a few GB storage space, and Julia with graphing modules is huge, too. You can hardly
install them on a quite old computer and run smoothly.</p>

<p>Mathly is especially good for instructors of linear algebra and numerical computing for teaching. It takes no time to
start Lua and load mathly. While developing code and doing computation in a lecture, they can simply focus on delivery
of course contents and never need to worry if their computers work too slowly or even collapse. Besides, an extra benefit
of using Lua is that Lua is so simple and natural a language that even students without programming skills can understand most
of Lua scripts.</p>

<h2>Which version of Lua is needed?</h2>
<p>Mathly is developed in Lua 5.4.6. It works with the present newest version 5.4.7. It might work with previous versions.</p>
<p>You may download Lua source code in <a href="https://lua.org/">https://lua.org/</a> and compile it yourself or simply
download prebuilt binary commands for Microsoft Windows in, say,
<a href="https://www.nuget.org/packages/lua/">https://www.nuget.org/packages/lua/</a>. Another way to get prebuilt Lua is to
download <a href=https://studio.zerobrane.com/>ZeroBrane Studio</a>, a lightweight Lua IDE for various platforms. It may come with
multiple versions of Lua.</p>
<h2>Where to place the downloaded files of this module?</h2>

<p>They can be placed in either</p>
<ol>
<li>the folder of your Lua code files to run/test or</li>
<li>(Windows) the folder, e.g., <code>c:/cygwin/bin/</code>, which contains the command, <code>lua.exe</code>:
<pre><code>...
lua.exe
browser-setting.lua
dkjson.lua
mathly.lua
plotly.lua
plotly-2.9.0.min.js
...
</code></pre><p></p>
(Linux) /usr/local/share/lua/5.4/
</li></ol>
<p>Note: The <code>*.lua</code> files can be compiled with <code>luac</code>. To use compiled modules, we set
<code>package.path</code> first as follows:</p>
<p><code>package.path = "./?.luac;;"</code></p>

<h2>You may need to edit the file <code>browser-setting.lua</code>.</h2>
<p>See comments in the very file.</p>

<h2>Two important things you need to know</h2>

<p><B>1. The difference between Lua tables and mathly matrices</B></p>
<p>Tables are the only data structure Lua offers. However, we may use it as arrays, vectors, matrices, dictionaries, and
so on. For example, <code>{}</code>, <code>{'ab'}</code>, <code>{1, 2, 3}</code>, <code>{{1, 2, 3}, {1, 2, 3, 4}}</code>,
<code>{1, 'ab', { 2, 3, {4}}}</code>, <code>{layout={width=900, height=400, grid={rows=2, columns=2}, title='Demo'}</code>
are all tables.</p>

<p><b>A mathly matrix is obtained/generated</b> by mathly 'constructor', functions like <code>zeros</code>, <code>ones</code>,
<code>rand</code>, <code>randi</code>, <code>reshape</code>, <code>submatrix</code>, <code>c</code>, <code>r</code>, or
matrix operations like <code>A^T</code>, <code>inv(A)</code>, <code>rref(B)</code>, and
<code>2 * A  - 3 * B + 4</code>, given that <code>A</code> and <code>B</code> are <code>nxn</code> mathly matrices. An element in the
<code>i</code>th row and <code>j</code>th column is addressed as <code>A[i][j]</code>.</p>

<p>Simply speaking, a mathly matrix is a table (of tables), but a table may not be a mathly matrix.</p>

<p><B>2. We can only apply matrix operations on mathly matrices; if an operation involves two objects, at least one must be a mathly matrix.</b>
To apply matrix operations on ordinary Lua tables, conversion is needed and done first through mathly 'constructor',
<code>c</code>, <code>r</code>, or <code>reshape</code>. For example,</p>
<pre><code>
mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}   -- a, b, c, d, A, B, C, D, and E are all mathly matrices
b = {{1}, {2}, {3}}; b = mathly(b) -- or b = cc{1, 2, 3}
c = mathly(1, 10, 5)
d = mathly(1, 10, 0)      --  same as f = mathly(zeros(1, 10))
A = mathly(10, 10)
B = mathly(1, 10)
C = randi(100, 10, 1)     -- a column vector of random integer numbers (from 1 to 100)
D = rand(10, 2)           -- a 10x2 matrix of random numbers (from 0 to 1)
E = reshape(C, 3)         -- a 3x4 matrix; 4 is determined by mathly

3*a - 10
2*c + 5 * d - 3
-- inv(A) * B             -- not allowed as in math
inv(A) * B^T
inv(A) * randi(50, 1, 10) -- mathly knows how to handle a Lua table
randi(50, 1, 10) * inv(A) -- randi(50, 1, 10) here in its context

A = randi(100, 10, 5)
B = randi(100, 5, 3)
C = rand(3, 1)
A - 2
A * B
A * B * C
B * C
C^T * B^T

A = randi(100, 4)
B = randi(50, 4)
C = 3 * A - 4 * B + 5
A^2

x = linspace(0, pi, 10)   -- x, y, and z are not mathly matrices/vectors.
y = cos(x)
z = sin(x)

-- 3 * y                  -- not allowed/defined
-- y + z                  -- not allowed/defined
mathly(y) + z             -- y + mathly(z), or mathly(y) + mathly(z) -- at least one must be a mathly matrix
2*rr(y) - 3 * rr(z)       -- both y and z must be converted to mathly matrices

x = {1, 2, 3}
rr(x)^2
rr(x) * x                 -- x * cc(x), or rr(x) * cc(x) -- mathly tries to convert a table to a row/column
cc(x) * x                 -- vector according to the context

rr(x) * rr(x)             -- the product of two row (or column) vectors is like x .* y in MATLAB
cc(x) * cc(x)             --

Y = mathly(y)
display(y)
display(Y)                -- print a table, including a mathly matrix, with structure
disp(Y)                   -- print a mathly matrix

A = randi({-10,10}, 4); B = copy(A); C = copy(A)
rref(A)                   -- warn: A and B are modified (for performance)
inv(B)                    --
inv(submatrix(C, 1, 1, 3, 3))
</code></pre>

<p>A mathly row vector is a <code>1xn</code> mathly matrix, and a mathly column vector is a <code>nx1</code> mathly matrix.
They are all matrices and, thus, an element must be addressed like <code>A[1][i]</code> (for a row vector) or <code>A[i][1]</code>
(for a column vector), which is really inconvenient and ugly because we human beings never write this way!</p>

<p><i>Mathly tries its best to allow us to write math expressions as we do on paper.</i> Therefore, <code>ones</code>,
<code>zeros</code>, <code>rand</code> and <code>randi</code> generate each a table rather than a mathly matrix if
used this way, say, <code>ones(1, 100)</code>. This allows us to generate a table of specified length and
address it conveniently like <code>x[i]</code> instead of <code>x[1][i]</code>. This is also why functions like
<code>linspace</code>, <code>seq</code>, and <code>range</code> all generate a table rather than a mathly row/column vector.

<p>If you want full control, you can use <code>c</code> or <code>r</code> to convert an ordinary table to a column
or row vector. (See <a href=#cc><code>cc(x)</code>, <code>rr(x)</code>, <code>tt(x)</code></a>)</p>
<h2><a name=math></a>Basic Mathematical Functions</h2>
<p>Basic math functions are each now able to work on Lua tables, including mathly matrices. They are
<code>abs</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>ceil</code>, <code>cos</code>,
<code>deg</code>, <code>exp</code>, <code>floor</code>, <code>log</code>, <code>rad</code>, <code>random</code>,
<code>sin</code>, <code>sqrt</code>, and <code>tan</code>. They evaluate a function at every number in a
table and keep the structure of the table.</p>

<p>For example, <code>abs({1, -2, {-3, 4, {5, -6}}})</code> evaluates Lua built-in function <code>math.abs</code>
at every number in the table and thus gives {1, 2, {3, 4, {5, 6}}}.</p>

<p>Note: With each of these functions, should we use, say, <code>sin(x)</code> or <code>math.sin(x)</code>?
<B>You can always use <code>sin(x)</code>. However, if you know <code>x</code> is a number, you may call
<code>math.sin(x)</code> to get a little improvement in performance.</p></B>

<p>Mathly also provides four commonly used constants. They are:</p>
<table><tbody>
<tr><td><code>pi = 3.1415926535898</code></td><td width=40></td><td>It is simply <code>math.pi</code>.</td></tr>
<tr><td><code>e = 2.718281828459</code></td><td width=40></td><td>It is <code>math.exp(1)</code>.</td></tr>
<tr><td><code>eps = 2.220446049250313e-16</code></td><td width=40></td><td>It is the machine epsilon, i.e., the smallest difference between any two numbers.</td></tr>
<tr><td><code>phi = 1.6180339887499</code></td><td width=40></td><td>It is the golden ratio, <code>(1 + math.sqrt(5)) / 2</code>.</td></tr>
</tbody>
</table>
<p></p>
<p><u>Note</u>: <code>T</code> is reserved by mathly for finding the transpose of a matrix, e.g., <code>A^T</code>, where <code>A</code> is a mathly matrix.</p>

<a name=mathly></a><h2><a href=#top>The following table summarizes other functions provided by <code>mathly</code>.</a></h2>
<table>
<tbody>
<tr><td width="25%"><a href=#all><code>all(x, f)</code></a></td><td width=1%> </td><td width=74%>Test if <code>f(x)</code> is true for every number in <code>x</code>.</td></tr>
<tr><td><a href=#any><code>any(x, f)</code></a></td><td> </td><td>Test if there is any number in <code>x</code> such that <code>f(x)</code> is true.</td></tr>
<tr><td><a href=#apply><code>apply(f, ...)</code></a></td><td> </td><td>As with some other programming languages like <i>Mathematica</i>, call function <code>f</code> with the arguments.</td></tr>
<tr><td><code><a href=#cc>cc(x)</a></code></td><td> </td><td>Convert a table <code>x</code> into a column vector.</td></tr>
<tr><td><code>clc()</code></td><td> </td><td>Clear Lua console.</td></tr>
<tr><td><code>clear()</code></td><td> </td><td>Delete all user-defined variables and their values in memory and make it ready for a new task.</td></tr>
<tr><td><a href=#copy><code>copy(x)</code></a></td><td> </td><td>Make a deep copy of <code>x</code>.</td></tr>
<tr><td><a href=#cross><code>cross(a, b)</code></a></td><td> </td><td>Calculate the cross/vector product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>}</code> and <code>b = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>}</code>.</td></tr>
<tr><td><code>det(A)</code></td><td> </td><td>Calculate the determinant of a square matrix <code>A</code>. <u>Note</u>: A is modified.</td></tr>
<tr><td><a href=#diag><code>diag(A, ...)</code></a></td><td> </td><td>Return a column vector consisting of specified diagonal entries of mathly matrix <code>A</code> or create a mathly matrix with vector <code>A</code> as its diagonal entries.</td></tr>
<tr><td><a href=#disp><code>disp(x)</code></a></td><td> </td><td>Print a mathly matrix.</td></tr>
<tr><td><a href=#display><code>display(x)</code></a></td><td> </td><td>Print a table with structure.</td></tr>
<tr><td><a href=#dot><code>dot(a, b)</code></a></td><td> </td><td>Calculate the dot/inner product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>}</code> and <code>b = {b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub>}</code>.</td></tr>
<tr><td><a href=#expand><code>expand(A, m, n, v)</code></a></td><td> </td><td>Return an expanded/shrinked <code>mxn</code> mathly matrix with value <code>v</code>'s added or entries dropped.</td></tr>
<tr><td><code>eye(n)</code></td><td> </td><td>Return a <code>nxn</code> identity mathly matrix.</td></tr>
<tr><td><a href=#filter><code>filter(A, f)</code></a></td><td> </td><td>Check if each element of matrix <code>A</code> makes <code>f(x)</code> true or not, return 1 or 0 for the element.</td></tr>
<tr><td><a href=#flatten><code>flatten(x)</code></a></td><td> </td><td>Remove the structure of <code>x</code> and return a table of all atomic elements in <code>x</code> in order.</td></tr>
<tr><td><a href=#fliplr><code>fliplr(A)</code></a></td><td> </td><td>Return a matrix with columns of matrix <code>A</code> reversed.</td></tr>
<tr><td><a href=#flipud><code>flipud(A)</code></a></td><td> </td><td>Return a matrix with rows of matrix <code>A</code> reversed.</td></tr>
<tr><td><a href=#format><code>format(fmt)</code></a></td><td> </td><td>Reset or specify the format of the output of <code>disp(...)</code>.</td></tr>
<tr><td><a href=#hasindex><code>hasindex(table, index)</code></a></td><td> </td><td>Check if <code>table</code> contains <code>index</code>.</td></tr>
<tr><td><a href=#horzcat><code>horzcat(A, B, ...)</code></a></td><td> </td><td>Concatenate matrices <code>A</code>, <code>B</code>, ... in order horizontally. Matrices must have the same number of rows.</td></tr>
<tr><td><a href=#inv><code>inv(A)</code></a></td><td> </td><td>Return the inverse of a square mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</td></tr>
<tr><td><code>isinteger(x)</code></td><td> </td><td>Check if <code>x</code> is an integer.</td></tr>
<tr><td><a href=#ismember><code>ismember(x, table)</code></a></td><td> </td><td>Check if <code>x</code> is a member of <code>table</code>.</td></tr>
<tr><td><code>length(x)</code></td><td> </td><td>Return the length of a table or string.</td></tr>
<tr><td><a href=#linsolve><code>linsolve(A, b, opt)</code></a></td><td> </td><td>Solve a linear system <code>Ax = b</code> and return the solution. <u>Note</u>: Both <code>A</code> and <code>b</code> can be modified.</td></tr>
<tr><td><a href=#linspace><code>linspace(x, y, n)</code></a></td><td> </td><td>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code> and ending at <code>y</code>.</td></tr>
<tr><td><a href=#lu><code>lu(A)</code></a></td><td> </td><td>Return <code>L</code> and <code>U</code> of LU factorization <code>A = LU</code>.</td></tr>
<tr><td><a href=#map><code>map(f, tbl)</code></a></td><td> </td><td>Apply function <code>f</code> to each atomic element in table <code>tbl</code> and return the result with the same structure of the table.</td></tr>
<tr><td><a href=#max><code>max(x)</code></a></td><td> </td><td>If <code>x</code> is a table/array, return the largest of all elements of the table; if it is a matrix, ...</td></tr>
<tr><td><a href=#mean><code>mean(x)</code></a></td><td> </td><td>Return mean value of numbers in <code>x</code>.</td></tr>
<tr><td><a href=#min><code>min(x)</code></a></td><td> </td><td>If <code>x</code> is a table/array, return the smallest of all elements of the table; if it is a matrix, ...</td></tr>
<tr><td><code>norm(x)</code></td><td> </td><td>Return the Euclidean norm of a row/column vector <code>x</code>.</td></tr>
<tr><td><a href=#ones><code>ones(m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 1. If <code>m = 1</code>, return a table.</td></tr>
<tr><td><a href=#plot><code>plot(x, y, ...)</code></a></td><td> </td><td>Plot the graph(s) of functions defined by data points <code>x</code> and <code>y</code> and ...</td></tr>
<tr><td><a href=#polyval><code>polyval(coefs, x)</code></a></td><td> </td><td>Evaluate at <code>x</code> the value of a polynomial of which the coefficients are specified in a table <code>coefs</code>.</td></tr>
<tr><td><a href=#printf><code>printf(...)</code></a></td><td> </td><td>Print formatted text like <code>printf</code> in C/C++.</td></tr>
<tr><td><a href=#prod><code>prod(A)</code></a></td><td> </td><td>If <code>A</code> is a table or mathly row/column vector, return the product of its elements; if A is a <code>mxn</code> matrix, ...</td></tr>
<tr><td><a href=#qr><code>qr(A)</code></a></td><td> </td><td>Return <code>Q</code> and <code>R</code> of QR factorization <code>A = QR</code>.</td></tr>
<tr><td><code><a href=#cc>rr(x)</a></code></td><td> </td><td>Convert a table <code>x</code> into a row vector.</td></tr>
<tr><td><a href=#rand><code>rand(m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> mathly matrix of which each element is a random number in [0, 1]. If <code>m = 1</code>, return a table.</td></tr>
<tr><td><a href=#randi><code>randi(...)</code></a></td><td> </td><td>Return a mathly matrix of which each element is a random integer in a specified range.</td></tr>
<tr><td><a href=#range><code>range(x, y, s)</code></a></td><td> </td><td>Return a table of numbers starting at <code>x</code>, in between <code>x</code> and <code>y</code>, and incrementing by <code>s</code>.</td></tr>
<tr><td><code><a href=#remake>remake(A, opt)</a></code></td><td> </td><td>Generate a lower, upper, diagonal, symmetrical, or ...  matrix from matrix <code>A</code>.</td></tr>
<tr><td><a href=#repmat><code>repmat(A, m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> block matrix with each entry a copy of matrix <code>A</code>.</td></tr>
<tr><td><a href=#reshape><code>reshape(A, m, n)</code></a></td><td> </td><td>Rearrange existing elements in a table or mathly matrix <code>A</code> and return a new <code>mxn</code> mathly matrix.</td></tr>
<tr><td><a href=#rref><code>rref(A, ..)</code></a></td><td> </td><td>Return the reduced row-echelon form of a mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</td></tr>
<tr><td><a href=#save><code>save(datafile, ...)</code></a></td><td> </td><td>Save specified or all user-defined variables and their values to file <code>datafile</code>.</td></tr>
<tr><td><a href=#seq><code>seq(x, y, n)</code></a></td><td> </td><td>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code>, in <code>[x, y]</code>, ending at <code>y</code>.</td></tr>
<tr><td><code>size(A)</code></td><td> </td><td>Return the dimensions of a mathly matrix <code>A</code>.</td></tr>
<tr><td><a href=#printf><code>sprintf(...)</code></a></td><td> </td><td>Return a formatted string, while <code>printf</code> prints one.</td></tr>
<tr><td><a href=#std><code>std(x, opt)</code></a></td><td> </td><td>Return the standard deviation of numbers in <code>x</code>.</td></tr>
<tr><td><a href=#strcat><code>strcat(...)</code></a></td><td> </td><td>Horizontally concatenate input strings and return the resulted string.</td></tr>
<tr><td><a href=#submatrix><code>submatrix(A, i, j, m, n, sr, sc)</code></a></td><td> </td><td>Return a mathly matrix, a block of mathly matrix <code>A</code>, starting at the <code>i</code>-th row and <code>j</code>-th column and ending at the <code>m</code>-th row and <code>n</code>-th column wtih row step <code>sr</code> and column step <code>sc</code>.</td></tr>
<tr><td><a href=#subtable><code>subtable(tbl, i, j, s)</code></a></td><td> </td><td>Return a slice of the table <code>tbl</code> starting from the <code>i</code>-th element to the <code>j</code>-th one with step size <code>s</code>.</td></tr>
<tr><td><a href=#sum><code>sum(A)</code></a></td><td> </td><td>If <code>A</code> is a table or mathly row/column vector, return the sum of its elements; if A is a <code>mxn</code> matrix, ...</td></tr>
<tr><td><a href=#tblcat><code>tblcat(t<sub>1</sub>, t<sub>2</sub>, ...)</code></a></td><td> </td><td>Concatenate tables <code>t<sub>1</sub></code>, <code>t<sub>2</sub></code>, ... and return the resulted table. The tables here may just be numbers or strings.</td></tr>
<tr><td><code><a href=#cc>tt(x, i1, i2, s)</a></code></td><td> </td><td>Convert a mathly matrix to a table columnwisely or flatten any other table first and and return a specified slice of the resulted table.</td></tr>
<tr><td><a href=#tic><code>tic()</code></a></td><td> </td><td>Start a wall-clock timer.</td></tr>
<tr><td><a href=#toc><code>toc</code></a></td><td> </td><td>Print or return elapsed time on a wall-clock timer.</td></tr>
<tr><td><a href=#unique><code>unique(tbl)</code></a></td><td> </td><td>Return the same data as in tbl but with no repetitions.</td></tr>
<tr><td><a href=#var><code>var(x, opt)</code></a></td><td> </td><td>Return the variance of numbers in <code>x</code>.</td></tr>
<tr><td><a href=#vertcat><code>vertcat(A, B, ...)</code></a></td><td> </td><td>Concatenate matrices <code>A</code>, <code>B</code>, ... in order vertically. Matrices must have the same number of columns.</td></tr>
<tr><td><a href=#what><code>what(A, B)</code></a></td><td> </td><td>Return a column vector of elements of <code>A</code> columnwisely if the corresponding element in <code>B</code> is 1.</td></tr>
<tr><td><code>who()</code></td><td> </td><td>List all user-defined variables in the memory.</td></tr>
<tr><td><a href=#zeros><code>zeros</code></a></td><td> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 0. If <code>m = 1</code>, return a table.</td></tr>
</tbody>
</table>

<h4>&bull; &nbsp; <a name=any></a><a name=all href=#mathly><code>all(x, f)</code>, <code>any(x, f)</code></a></h4>
<ol>
<li><code>all(x, f)</code>: Test if <code>f(x)</code> is true for every number in <code>x</code>.
<p>If <code>x</code> is a table or a row/column vector, returns 1 if all elements of the table make <code>f(x)</code> true.</p>
<p>If <code>x</code> is a mathly matrix, returns a row vector of 1's and 0's with each element indicating
if all of the elements of the corresponding column of the matrix make <code>f(x)</code> true.</p></li>

<li><code>any(x, f)</code>: Test if there is any number in <code>x</code> such that <code>f(x)</code> is true.
<p>If <code>x</code> is a mathly matrix, it returns a row vector of 1's and 0's with each element indicating
if there is any element of the corresponding column of the matrix which makes <code>f(x)</code> true.</p>
<p>If <code>x</code> is a simple table, a row or column vector, return 1 if there is any element of the table which makes <code>f(x)</code> true.</p>
<p>Note: <code>f(x)</code> returns true or false (default: <code>x ~= 0</code>). It makes the two functions more useful than those in MATLAB.</p></li>
</ol>
<pre><code>
mathly = require 'mathly'
A = mathly{{1, 2, 3}, {2, 3, 4}}
all(A, isinteger)
-- 1  1  1
any(A)
-- 1  1  1
any(A, function(x) return x > 2 end)
-- 0  1  1
x = {1, 2, 3, 4, 5, 6}
any(x, function(x) return x % 2 == 0 end)
-- 1
</code></pre>
<h4>&bull; &nbsp; <a name=apply href=#mathly><code>apply(f, ...)</code></a></h4>
<p>As with some other programming languages like <i>Mathematica</i>, it evaluates function <code>f</code> with provided arguments.</p>
<pre><code>
require 'mathly'
function f(x, y, z) return x + y + z end
apply(f, {1, 2, 3})
-- 6
</code></pre>
<h4>&bull; &nbsp; <a name=horzcat href=#mathly><code>horzcat(A, B, ...)</code></a></h4>
<P>Concatenate matrices A, B, ... in order horizontally. Matrices must have the same number of rows.</P>
<p><em>Operator .. can be used to repalce <code>horzcat</code>.</em></p>
<p>See also: <a href=#vertcat><code>vertcat</code></a></p>
<pre><code>
m = require('mathly')
A = m{{1, 2}, {3, 4}}
disp(A)
-- 1  2
-- 3  4
B = m{{5}, {6}}
disp(B)
-- 5
-- 6
C = m{{7, 8, 9}, {10, 11, 12}}
disp(C)
--  7  8  9
-- 10 11 12
D = A .. B .. C -- same as horzcat(A, B, C)
disp(D)
-- 1  2  5  7  8  9
-- 3  4  6 10 11 12
disp(rr{1, 2, 3} .. rr{4, 5})
--  1  2  3  4  5

b = {5, 6}
disp(A .. cc(b)) -- augmented coefficient matrix for Ax = b
-- 1  2  5
-- 3  4  6
</code></pre>
<h4>&bull; &nbsp; <a name=vertcat href=#mathly><code>vertcat(A, B, ...)</code></a></h4>
<P>Concatenate matrices A, B, ... in order vertically. Matrices must have the same number of columns.</P>
<p>See also: <a href=#horzcat><code>horzcat</code></a></p>
<pre><code>
mathly = require('mathly')
A = mathly{{1, 2, 3}}
disp(A)
-- 1 2 3
B = mathly{{4, 5, 6}, {7, 8, 9}}
disp(B)
-- 4 5 6
-- 7 8 9
C = mathly{{10, 11, 12}}
disp(C)
-- 10 11 12
D = vertcat(A, B)
disp(D)
-- 1 2 3
-- 4 5 6
-- 7 8 9
E = vertcat(A, B, C)
disp(E)
-- 1   2  3
-- 4   5  6
-- 7   8  9
-- 10 11 12
</code></pre>
<h4>&bull; &nbsp; <a name=copy href=#mathly><code>copy(x)</code></a></h4>
<P>Make a deep copy of <code>x</code>.</P>
<pre><code>
m = require('mathly')
a = {1, 2, {3, 4, {5, 6}}}
b = copy(a)
b[3] = 0
display(a)
-- {1, 2, {3, 4, {5, 6}}}
display(b)
-- {1, 2, 0}

A = m{{1, 2}, {3, 4}}
B = copy(A)
inv(A) -- A is modified
disp(A)
-- 1 0
-- 0 1
disp(B)
-- 1 2
-- 3 4
</code></pre>
<h4>&bull; &nbsp; <a name=cross href=#mathly><code>cross(a, b)</code></a></h4>
<P>Return the cross/vector product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>}</code>
and <code>b = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>}</code>.</P>
<pre><code>
require 'mathly'
display(cross({1, 2, 3}, {3, 4, 5}))
-- {-2, 4, -2}
</code></pre>
<h4>&bull; &nbsp; <a name=diag href=#mathly><code>diag(A, ...)</code></a></h4>
<ol>
<li><code>diag( A, k )</code>, where <code>A</code> is a mathly <code>mxn</code> matrix, <code>m &ne; 1</code> and <code>n &ne; 1</code>.
<p>Return the table of all entries of the <code>k</code>-th diagonal as a column vector.</p>
<p>The second argument <code>k</code> is optional. Its default value is 0.</p>
<p>Which diagonal? If <code>k = 0</code>, the main diagonal; if <code>k = j</code>, the diagonal <code>j</code> rows above (if <code>j &gt; 0</code>)
or <code>-j</code> rows below the main diagonal (if <code>j &lt; 0</code>). E.g., if <code>k = 1</code>, the diagonal right above the main
diagonal; if <code>k = -1</code>, the diagonal right below the main diagonal.</p></li>

<li><code>diag(v)</code>, where <code>v</code> is a table or a row/column vector.
<p>Return a <code>nxn</code> matrix with <code>v</code> as its main diagonal, where <code>n = length(v)</code>.</p></li>

<li><code>diag(v, k)</code>, where <code>v</code> is a table or a row/column vector.
<p>If <code>k &gt; 0</code>, return a matrix with <code>v</code> as the diagonal <code>k</code> rows above the main diagonal.</p>
<p><code>If k &lt; 0</code>, return a matrix with <code>v</code> as the diagonal <code>-k</code> rows below the main diagonal</p>
<p>If <code>k = 0</code>, same as <code>diag(v)</code>.</p></li>

<li><code>diag(v, m, n)</code>, where <code>v</code> is a table or a row/column vector.</p>
<p>Return a <code>mxn</code> matrix with vector v (or first elements in it) as its main diagonal.</p></li>
</ol>
<pre><code>
m = require('mathly')
a = m{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}
disp(a)
-- 1  2  3
-- 2  3  4
-- 3  4  5
-- 4  5  6
disp(diag(a))
-- 1
-- 3
-- 5
disp(diag(a, 1))
-- 2
-- 4
disp(diag(a, -2))
-- 3
-- 5
diag({1, 2, 3})
-- 1  0  0
-- 0  2  0
-- 0  0  3
diag(cc{1, 2, 3, 4}, 3, 2)
-- 1  0
-- 0  2
-- 0  0
diag({1, 2, 3},2)
-- 0  0  1  0  0
-- 0  0  0  2  0
-- 0  0  0  0  3
-- 0  0  0  0  0
-- 0  0  0  0  0
diag({1, 2, 3},-1)
-- 0  0  0  0
-- 1  0  0  0
-- 0  2  0  0
-- 0  0  3  0
diag({2,3,4,5}, 1) + diag({1,2,3,4,5}) + diag({3,4,5,6}, -1) -- See also: <a name=diag1></a><a href=#remake1>remake</a>
-- 1  2  0  0  0
-- 3  2  3  0  0
-- 0  4  3  4  0
-- 0  0  5  4  5
-- 0  0  0  6  5
</code></pre>
<h4>&bull; &nbsp; <a name=disp href=#mathly><code>disp(A)</code></a> - Print a mathly matrix. If <code>A</code> is not a mathly matrix, <code>display</code> is called to print it.</h4>
<h4>&bull; &nbsp; <a name=display href=#mathly><code>display(x)</code></a> - Print a table with structure.</h4>
<pre><code>
require 'mathly'
a = eye(3)
disp(a)
-- 1 0 0
-- 0 1 0
-- 0 0 1
display(a)
-- {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}

x = {1, 2, {3, 4, {5, 6, {7, 8, {9}}}}}
display(x)
-- {1, 2, {3, 4, {5, 6, {7, 8, {9}}}}}
</code></pre>
<h4>&bull; &nbsp; <a name=dot href=#mathly><code>dot(a, b)</code></a></h4>
<P>Return the dot/inner product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, ...}</code>
and <code>b = {b<sub>1</sub>, b<sub>2</sub>, ...}</code>.</P>
<pre><code>
require 'mathly'
display(dot({1, 2, 3}, {3, 4, 5}))
-- 26
display(dot({1, 2}, {3, 4}))
-- 11
</code></pre>
<h4>&bull; &nbsp; <a name=flatten href=#mathly><code>flatten(x)</code></a></h4>
<p>Remove the structure of table <code>x</code> and return a table of all atomic elements in <code>x</code> in order.</p>
<p>If <code>x</code> is a mathly matrix, it does rowwisely. For columnwise flattening, see <a href=#tt><code>tt(...)</code></a>.</p>
<pre><code>
m = require('mathly')
x = {1, 2, {3, 4, {5, 6, {7, 8, {9}}}}}
y = flatten(x)
display(y)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9}

A = m{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
-- 1 2 3
-- 4 5 6
-- 7 8 9
a = flatten(A)
display(a)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9} -- row wise
b = flatten(A^T) -- or b = tt(A^T)
display(b)
-- {1, 4, 7, 2, 5, 8, 3, 6, 9} -- column wise
</code></pre>
<h4>&bull; &nbsp; <a name=hasindex href=#mathly><code>hasindex(table, index)</code></a></h4>
<p>Check if <code>table</code> contains <code>index</code>.</p>
<pre><code>
require 'mathly'
opt = {layout={width=900, height=400, grid={rows=2, columns=2}, title='Example'}}
print(hasindex(opt, 'grid'))
-- true
print(hasindex(opt, 'rows'))
-- true
print(hasindex(opt, 'color'))
-- false
</code></pre>
<h4>&bull; &nbsp; <a name=inv href=#mathly><code>inv(A)</code></a></h4>
<p>Return the inverse of a square mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</p>
<pre><code>
m = require('mathly')
I = eye(3)
A = m{{1, 2, 3}, {3, 4, 5}, {-1, 2, 0}}
B = copy(A)
C = inv(A) * B
disp(C)
--       1        0  -0.0000
--  0.0000   1.0000   0.0000
-- -0.0000  -0.0000        1
</code></pre>
<h4>&bull; &nbsp; <a name=ismember href=#mathly><code>ismember(x, table)</code></a></h4>
<p>Check if <code>x</code> is a member of <code>table</code>.</p>
<pre><code>
require 'mathly'
x = {1, 2, 3, {4, 5, {6}}}
print(ismember(3, x))
-- true
print(ismember(4, x))
-- false
</code></pre>
<h4>&bull; &nbsp; <a name=tblcat href=#mathly><code>tblcat(t<sub>1</sub>, t<sub>2</sub>, ...)</code></code></a></h4>
<p>Concatenate tables <code>t<sub>1</sub></code>, <code>t<sub>2</sub></code>, ... and return the resulted table. The tables here may just be numbers or strings.</p>
<p>See also: <a href=#strcat><code>strcat</code></a></p>
<pre><code>
m = require('mathly')
x = {1, 2}
y = {3, 4, {5}}
disp(tblcat(0, x, y, 10))
-- {0, 1, 2, 3, 4, {5}, 10}

z = m{{6}, {7}, {8}, {9}}
disp(tblcat(x, z, 11)) -- a column vector is automatically converted into a row vector
-- {1, 2, 6, 7, 8, 9, 11}
</code></pre>
<h4>&bull; &nbsp; <a name=linspace href=#mathly><code>linspace(x, y, n)</code></a></h4>
<p>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code> and ending at <code>y</code>.</p>
<pre><code>
require 'mathly'
x = linspace(0, 2*pi, 1000)
y = cos(x)
plot(x, y, '-or')
</code></pre>
<h4>&bull; &nbsp; <a name=map href=#mathly><code>map(f, tbl)</code></a></h4>
<p>Apply function <code>f</code> to each atomic element in table <code>tbl</code> and return the result with the same structure of the table.</p>
<pre><code>
m = require('mathly')
a = range(1, 10) -- seq(1, 10) or seq(10)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
function f(x) return x ^ 2 end
b = map(f, a)
display(b)
-- {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}

function g(x, y) return x + y end
display(map(g, a, b))
-- {2, 6, 12, 20, 30, 42, 56, 72, 90, 110}

x = {1, 2, {3, 4, {5, 6, {7}}}}
display(map(f, x))
{1, 4, {9, 16, {25, 36, {49}}}}

A = m{{1, 2, 3}, {3, 4, 5}, {-1, 2, 0}}
map(f, A) -- A is a mathly matrix, the result of map(f, A) is a mathly matrix, too.
-- 1   4   9
-- 9  16  25
-- 1   4   0

A = {{1, 2, 3}, {2, 3, 4}}
B = {{3, 4, 5}, {5, 6, 7}}
C = map(function(x, y) return x * y end, A, B) -- MATHLAB: A .* B
disp(C)
-- {{3, 8, 15}, {10, 18, 28}}
</code></pre>
<h4>&bull; &nbsp; <a name=zeros></a><a name=rand></a><a name=randi></a><a name=ones href=#mathly><code>ones</code>, <code>zeros</code>, <code>rand</code>, <code>randi</code></a></h4>
<p>The usage of these functions is the same except randi that can take more arguments.</p>
<table><tbody>
<tr><td width=20></td><td><code>ones(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 1.</td></tr>
<tr><td width=20></td><td><code>randi(...)</code></a></td><td> </td><td width=10> </td><td>Return a mathly matrix of which each element is a random integer in a specified range.</td></tr>
<tr><td width=20></td><td><code>zeros(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 0.</td></tr>
<tr><td width=20></td><td><code>rand(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is a random number in [0, 1].</td></tr>
<tr><td width=20></td><td> </td><td> </td><td width=10> </td><td> </td></tr>
<tr><td width=20></td><td> </td><td> </td><td width=10> </td><td><u>Note</u>: Each function returns a table rather than a mathly column vector if <code>m = 1</code>.</td></tr>
</tbody></table>
<pre><code>
require 'mathly'
A = ones(2) -- or ones(2, 2)
disp(A)
-- 1 1
-- 1 1
B = zeros(2, 3) + 5
disp(B)
-- 5 5 5
-- 5 5 5
disp(A * B)
-- 10 10 10
-- 10 10 10

C = zeros(1, 5)  -- return a table rather than a mathly matrix
-- C + 10 -- not allowed because C is not a mathly vector/matrix
display(C)
-- {0, 0, 0, 0, 0}

D = zeros(3, 1)  -- a mathly column vector
disp(D)
-- 0
-- 0
-- 0
display(D)
-- {{0}, {0}, {0}}
disp(2*D + 3)
-- 3
-- 3
-- 3

A = randi({0, 100}, 2, 3) -- each element is a random integer in [0, 100]
disp(A)
A = randi({50, 90}, 3, 1) -- each element is a random integer in [50, 90]
display(A)
A = randi({50, 90}, 1, 5) -- return a table rather than a mathly matrix
display(A)
</code></pre>
<table><tbody>
<p>&#x2713; &nbsp; The usage of <code>randi(...)</code> is different.</p>
<tr><td><code>randi(imax)</code></td><td> </td><td width=10> </td><td>Return an random integer in <code>[1, imax]</code>.</tr>
<tr><td><code>randi({imin, imax})</code></td><td> </td><td width=10> </td><td>Return an random integer in <code>[imin, imax]</code>.</tr>
<tr><td><code>randi(imax, m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is in <code>[1, imax]</code>. (<code>n</code> is optional. The default is <code>m</code>.)</tr>
<tr><td><code>randi({imin, imax}, m, n)</code></td><td> </td><td width=10> </td><td>Return a mxn mathly matrix of which each element is in <code>[imin, imax]</code>. (<code>n</code> is optional. The default is <code>m</code>.)</tr>
</tbody></table>
<h4>&bull; &nbsp; <a name=plot href=#mathly><code>plot(...)</code></a></h4>
<p>Plot the graph(s) of functions defined by data points , using specifications/options.</p>
<p><b>Some specifications:</b></p>
<ol>
<li>of a line, i.e., the graph of a function:<p><code>width</code>=5</p><p><code>style</code>=<code>'-'</code> [solid, <code>':'</code> (dot), or <code>'--'</code> (dash)]</p><p><code>mode</code>=<code>'lines+markers'</code>, <code>'lines'</code>, or <code>'markers'</code></p></li><p></p>
<li>of a marker:<p><code>size</code>=10</p><p><code>symbol</code>=<code>'circle'</code></p>
Some possible symbols are <code>circle</code>, <code>circle-open</code>, <code>circle-open-dot</code>, <code>cross</code>, <code>diamond</code>, <code>square</code>, <code>x</code>, <code>triangle-left</code>, <code>triangle-right</code>, <code>triangle-up</code>, <code>triangle-down</code>, <code>hexagram</code>, <code>star</code>, <code>hourglass</code>, <code>bowtie</code>.</li><p></p>
<li>of a plot:<p><code>layout</code>={<code>width</code>=500, <code>height</code>=400, <code>grid</code>={<code>rows</code>=2, <code>columns</code>=2}, <code>title</code>='Demo'}</p></li>
</ol>
<p><b>Some examples:</b></p>
<pre><code>
require 'mathly'
x = linspace(0, pi, 100)
y1 = sin(x)
y2 = map(math.cos, x)
y3 = map(function(x) return x^2*math.sin(x) end, x)

specs1 = {layout={width=700, height=900, grid={rows=4, columns=1}, title='Example'}}
specs2 = {color='blue', name='f2', layout={width=500, height=500, grid={rows=4, columns=1}, title='Demo'}}
specs3 = {width=5, name='f3', style=':', color='cyan', symbol='circle-open', size78}

plot(math.sin, '--r') -- plot a function
plot(x, y1)           -- plot a function defined by x and y1
plot(x, y1, math.cos, x, y2, specs1, math.sin, '--r')
plot(x, y1, '--xr', x, y2, {1.55}, {-0.6}, {symbol='circle-open', size=10, color='blue'})
plot(x, y1, '--xr', x, y2, ':g')
plot(x, y1, {xlabel="x-axis", ylabel="y-axis", color='red'})
plot(x, y1, specs1, x, y2, x, y3, 'o')
plot(x, y1, specs3, x, y2, specs2, math.sin, x, y3, specs1)

plot(rand(125, 4)) -- plots functions defined in each column of a matrix with the range of x from 0 to # of rows
plot(rand(125, 4),{layout={width=900, height=400, grid={rows=2, columns=2}, title='Demo'}, names={'f1', 'f2', 'f3', 'g'}})
plot(rand(125, 4), {layout={width=900, height=400, grid={rows=2, columns=2}, title='Example'}})
plot(rand(100,3), {layout={width=900, height=400, grid={rows=3, columns=2}, title='Example'}}, rand(100,2))
plot(rand(100, 2), linspace(1,100,1000), sin(linspace(1,100,1000)), '-og', rand(100, 3))
</code></pre>
<h4>&bull; &nbsp; <a name=polyval href=#mathly><code>polyval(coefs, x)</code></a></h4>
<p>Evaluate at <code>x</code> the value of a polynomial of which the coefficients are specified
in a table <code>coefs</code>.</p>
<p>For a polynomial of <code>p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + ... +
a<sub>1</sub>x + a<sub>0</sub></code>,
<code>coefs = {a<sub>n</sub>, a<sub>n-1</sub>, ..., a<sub>0</sub>}</code>.
For example, <code>p(x) = -2x<sup>4</sup> + 4x<sup>2</sup> - 5x</code>, <code>coef = {-2, 0, 4, -5, 0}.</code></p>
<pre><code>
require 'mathly'
x = polyval({1, 2, 1}, 0) -- evaluate x<sup>2</sup> + 2x + 1 at x = 0
print(x)
-- 1.0
</code></pre>
<h4>&bull; &nbsp; <a name=sum></a><a name=prod href=#mathly><code>prod(A)</code>, <code>sum(A)</code></a></h4>
<ol>
<li>If <code>A</code> is a table or mathly row/column vector, return the product/sum of its elements;</li>
<li>If <code>A</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the product/sum of
the <code>i</code>-th column of <code>A</code>.</p></li>
</ol>
<pre><code>
m = require('mathly')
a = {1, 2, 3}
print(sum(a))
-- 6

a = {{1}, {2}, {3}}
print(sum(a))
-- 6

a = m{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}
disp(a)
--  1  2  3
--  2  3  4
--  3  4  5
disp(sum(a))
-- {6, 9, 12}
disp(prod(a))
-- {6, 24, 60}
</code></pre>
<h4>&bull; &nbsp; <a name=range href=#mathly><code>range(x, y, s)</code></a></h4>
<p>Return a table of numbers starting at <code>x</code>, in between <code>x</code> and <code>y</code>, and incrementing by <code>s</code> (1 by default).</p>
<pre><code>
require 'mathly'
x = range(1, 10)
disp(x)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

display(range(10, 1, -1))
-- {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}

disp(range(0, 6, 0.5))
-- {0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6}
</code></pre>
<h4>&bull; &nbsp; <a name=reshape href=#mathly><code>reshape(A, m, n)</code></a></h4>
<p>Rearrange existing elements in a table or mathly matrix <code>A</code> and return a new <code>mxn</code> mathly matrix.</p>
<pre><code>
m = require('mathly')
reshape({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3) -- return a 3x4 mathly matrix, where 4 is automatically determined
-- 1  4  7  10
-- 2  5  8  0
-- 3  6  9  0

reshape({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3, 5) -- <b>column wise</b>; no sufficient numbers in a table? fill with 0
-- 1  4  7  10  0
-- 2  5  8  0   0
-- 3  6  9  0   0

a = m{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}
disp(a)
-- 1  2  3
-- 2  3  4
-- 3  4  5
b = reshape(a, 2)
disp(a)
disp(b)
-- 1  3  3  3  5
-- 2  2  4  4  0
c = reshape(a, 2, 7)
disp(c)
-- 1  3  3  3  5  0  0
-- 2  2  4  4  0  0  0
</code></pre>
<h4>&bull; &nbsp; <a name=rref href=#mathly><code>rref(A, ...)</code></a></h4>
<p>If there is one more argument, i.e., <code>rref(A, B)</code>, <code>A</code> and <code>B</code> will be merged horizontally into A.
<p><code>A</code> and <code>B</code> must be mathly matrices with the same row number.</p>
<p>Return the reduced row-echelon form of a mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> and <code>B</code> are modified.</p>
<p>To solve <code>Ax = b</code>, call <code>rref(A, b)</code> first, and <code>b</code> gives the solution.</p>
<pre><code>
m = require('mathly')
a = m{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}
disp(a)
--  1  2  3
--  2  3  4
--  3  4  5
--  4  5  6
rref(a)
disp(a)
--  1  0 -1
--  0  1  2
--  0  0  0
--  0  0  0

-- To solve Ax = b<sub>1</sub>, Ax = b<sub>2</sub>, and Ax = b<sub>3</sub>:
m = require('mathly')
A = m{{1, 2, 3}, {2, 3, 4}, {0, -1, 2}}
b1 = m{{1},{2},{3}}
b2 = m{{1},{0},{5}}
b3 = m{{-2},{1},{2}}

B = m(horzcat(b1, b2, b3))
rref(A, B)
disp(B)
--  1.7500  -1.2500   7.2500
-- -1.5000  -1.5000  -3.5000
--  0.7500   1.7500  -0.7500
-- the solutions are
display((B^T)[1])
-- {1.7500, -1.5000, 0.7500}
display((B^T)[2])
-- {-1.2500, -1.5000, 1.7500}
display((B^T)[3])
-- {7.2500, -3.5000, -0.7500}
</code></pre>
<h4>&bull; &nbsp; <a name=save href=#mathly><code>save(datafile, ...)</code></a></h4>
<p>Save specified or all user-defined variables and their values to file <code>datafile</code>.</p>
<pre><code>
mathly = require 'mathly'
a = randi(100, 3, 2)
disp(a)
--  48  43 -- it varies
--  71  72
--  66   5
b = {1, 2, {3, {4, {5, 6, {7}}}}}
c = 100
save('data_1.lua')  -- save all user-defined variables and their values to a file,
                    -- data_1.lua, in present working directory
                    -- to save to different place? e.g., 'D:/Workspace/data_1.lua'
save('data_2.lua', 'a', 'b')  -- save variables a, b, and their values to a file,
                    -- data_2.lua, in present working directory
clear()
print(a, b, c)
-- nil nil nil -- not defined

dofile('data_2.lua') -- load/recover the data
a = mathly(a)
disp(a)
--  48  43
--  71  72
--  66   5
disp(b)
-- {1, 2, {3, {4, {5, 6, {7}}}}}
print(c)
-- nil
</code></pre>
<h4>&bull; &nbsp; <a name=seq href=#mathly><code>seq(x, y, n)</code></a></h4>
<p>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code>, in <code>[x, y]</code>, ending at <code>y</code>.</p>
<pre><code>
require 'mathly'
x = seq(1, 10) -- same as range(1, 10)
disp(x)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

x = seq(0, 1, 10) -- same as linspace(0, 1, 10)
display(x)
-- {0, 0.1111, 0.2222, 0.3333, 0.4444, 0.5556, 0.6667, 0.7778, 0.8889, 1.0000}
</code></pre>
<h4>&bull; &nbsp; <a name=linsolve href=#mathly><code>linsolve(A, b, opt)</code></a></h4>
<p>Solve a linear system <code>Ax = b</code> and return the solution.</p>
<p>The argument <code>opt</code> is optional:</p>
<ol>
<li><code>'LT'</code>: <code>A</code> is lower triangular</li>
<li><code>'UT'</code>: <code>A</code> is upper triangular</li>
</ol>
<p>If <code>A</code> is neither upper nor lower triangular, call <code>rref(A, b)</code> first, and <code>b</code> gives the solution, and both <code>A</code> and <code>b</code> are modified.</p>
<pre><code>
require 'mathly'
a = randi(100, 3)
aa = copy(a)
b = randi(100, 3, 1)
disp(a)
--  58  18  88 -- it varies
--  68  30  71
--  14  75  49
disp(b)
-- 89
-- 6
-- 4

x = linsolve(a, b)
disp(x)
-- -2.1499
-- -1.3064
--  2.6955

x = linsolve(aa, {89, 6, 4}) -- or linsolve(aa, {{89}, {6}, {4}})
disp(x)
-- -2.1499
-- -1.3064
--  2.6955
</code></pre>
<h4>&bull; &nbsp; <a name=submatrix href=#mathly><code>submatrix(A, i, j, m, n, sr, sc)</code></a></h4>
<p>Return a mathly matrix, a block of mathly matrix <code>A</code>, starting at the <code>i</code>-th row
and <code>j</code>-th column and ending at the <code>m</code>-th row and <code>n</code>-th column
with row step <code>sr</code> and column step <code>sc</code>.</p>
<pre><code>
m = require('mathly')

a = m{{22, 15, 94, 77, 48}, {43, 58, 96, 64,  5},
      {20, 85, 90, 37, 92}, {16, 67,  9, 56, 33}}
disp(a)
-- 22  15  94  77  48
-- 43  58  96  64   5
-- 20  85  90  37  92
-- 16  67   9  56  33
b = submatrix(a, 3, 2, 4, 4) -- default value of sr and sc is 1 each
disp(b)
--  85  90  37
--  67   9  56
B = submatrix(a, 1, 1, 4, 4, 2, 1) -- or submatrix(a, 1, 1, 4, 4, 2)
disp(B)
-- 22  15  94  77
-- 20  85  90  37
C = submatrix(a, 2, 1, 5, 5, 2, 3) -- or submatrix(a, 1, 1, 4, 4, 2)
disp(C)
-- 43  64
-- 16  56
</code></pre>
<h4>&bull; &nbsp; <a name=subtable href=#mathly><code>subtable(tbl, i, j, s)</code></a></h4>
<p>Return a slice of the table <code>tbl</code> starting from the <code>i</code>-th element to the <code>j</code>-th one with step size <code>s</code> (default: 1).</p>
<p>See also: <a href=#tt><code>tt(...)</code></a>.</p>
<pre><code>
m = require('mathly')
x = {1, 2, {3}, 4, {{5, 6, {7}}}}
display(subtable(x, 2, 4))
-- {2, {3}, 4}

a = m{1, 2, 3, 4, 5, 6, 7} -- {{1, 2, 3, 4, 5, 6, 7}}
display(subtable(a[1], 3, 5))
-- {3, 4, 5}

x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
y = subtable(x, 1, 11, 3)
display(y)
-- {1, 4, 7, 10}
</code></pre>
<h4>&bull; &nbsp; <a name=toc></a><a name=tic href=#mathly><code>tic()</code>, <code>toc(...)</code></a></h4>
<table><tbody>
<tr><td width=20></td><td><code>tic()</code></td><td> </td><td width=10> </td><td>Start a wall-clock timer.</td></tr>
<tr><td width=20></td><td><code>toc(...)</code></td><td> </td><td width=10> </td><td>Print or return elapsed time on a wall-clock timer.</td></tr>
</tbody></table>
<pre><code>
require 'mathly'

tic() -- start recording the time
for i = 1, 10000000 do
  x = math.cos(i) * math.sin(i)
end
toc()

x = toc(1) -- pass any none-nil value to toc to get the elapsed time; otherwise, print the elapsed time
printf("The loop took %.2f seconds.", x)
</code></pre>
<h4>&bull; &nbsp; <a name=sprintf></a><a name=printf href=#mathly><code>printf(...)</code>, <code>sprintf(...)</code></a></h4>
<p>This kind of functions is a commonly used tool for printing or preparing a formatted string in many programming languages like C/C++ and MATLAB. They print or prepare a formatted string.</p>
<p>These two functions depend on <a href="manual.html#pdf-string.format"><code>string.format</code></a>.</p>
<table><tbody>
<tr><td width=20></td><td><code>printf</code></td><td> </td><td width=10> </td><td>Print a formatted string.</td></tr>
<tr><td width=20></td><td><code>sprintf</code></td><td> </td><td width=10> </td><td>Prepare a formatted string.</td></tr>
</tbody></table>

<h4>&bull; &nbsp; <a name=max></a><a name=min href=#mathly><code>max(x)</code>, <code>min(x))</code></a></h4>
<p>If <code>x</code> is an array or row/column vector, return the largest/smallest of all elements in it; if it is a matrix, return a table consisting of the largest/smallest of each column of <code>x</code>.</p>
<table><tbody>
<pre><code>
require 'mathly'

x = {1, -10, 2, 31, 4, 7}
print(min(x), max(x))
-- -10  31

a = randi({-50, 50}, 3, 5)
disp(a)
-- -12  -19   -15    6  -11
--   3   43    36   29  -26
-- -38   -9   -16   20   16
display(min(a))
-- {-38, -19, -16, 6, -26}
disp(max(a))
-- {3, 43, 36, 29, 16}
</code></pre>

<h4>&bull; &nbsp; <a name=cc></a><a name=rr></a><a name=tt href=#mathly><code>cc(x...)</code>, <code>rr(x...)</code>, <code>tt(x)</code></a></h4>
<p>A matrix operation may be applied to an ordinary table. It takes the table as a row or column vector according to the very context.
If you want full control, you can use functions <code>c</code> and <code>r</code> to tell mathly whether the table is a column or row vector.</p>
<table><tbody>
<tr><td width=20></td><td><code>cc(x)</code></td><td> </td><td width=10> </td><td>Convert a table <code>x</code> into a column vector or return a specified column vector of <code>x</code>.</td></tr>
<tr><td width=20></td><td><code>rr(x)</code></td><td> </td><td width=10> </td><td>Convert a table <code>x</code> into a row vector or return a specified row vector of <code>x</code>.</td></tr>
<tr><td width=20></td><td><code>tt(x)</code></td><td> </td><td width=10> </td><td>Convert a mathly matrix/vector or a table (of tables) <code>x</code> to an ordinary table and return a slice of it.</td></tr>
</tbody></table>
<p>Note: Why not <code>c</code>, <code>r</code>, and <code>t</code>? It is because they can be easily used
as names of variables.</p>
<pre><code>
mathly = require('mathly')
a = mathly({1, 2, 3}, 3)
disp(a)
-- 1
-- 2
-- 3
a * {2, 3, 4}   -- or a * rr{2, 3, 4}, (3x1 matrix) * (1x3 matrix) --> 3x3 matrix
-- 2  3  4
-- 4  6  8
-- 6  9  12
a * cc{2, 3, 4} -- (3x1 matrix) * (3x1 matrix) --> (3x1 matrix) .* (3x1 matrix) in MATLAB
cc{2, 3, 4} * a --
-- 2
-- 6
-- 12
{2, 3, 4} * a   -- or rr{2, 3, 4} * a, (1x3 matrix) * (3x1 matrix) --> 1x1 matrix
-- 20

a = mathly({1, 2, 3})
disp(a)
-- 1  2  3
a * {2, 3, 4}   -- or a * cc{2, 3, 4}, (1x3 matrix) * (3x1 matrix) --> 1x1 matrix
-- 20
a * rr{2, 3, 4} -- (1x3 matrix) * (1x3 matrix) --> (1x3 matrix) .* (1x3 matrix) in MATLAB
-- 2  6  12

A = mathly{{52, 67, 82, 21}, {82, 15, 70, 42}, {94, 82, 50, 23}}
cc(A, 1)        -- return the 1st column of A
-- 52
-- 82
-- 94
rr(A, 3, 2)     -- return the 3rd row of A starting from the 2nd entry to the last
-- 82  50  23
rr(A, 3, 2, 3)  -- return the 3rd row of A starting from the 2nd entry to the 3rd one
-- 82  50
</code></pre>
<p>&#x2713; &nbsp; <code>tt(x, i1, i2, s)</code> may be used to replace <a href=#subtable><code>subtable</code></a>. If <code>x</code> is a mathly matrix, it is converted to a table columnwisely first;
if it is any other table, it is flattened first. Comparatively, <code>subtable</code> doesn't carry out any conversion.
For row wise flattening, see <a href=#flatten><code>flatten(tbl)</code></a>.</p>
<table><tbody>
<tr><td width=20></td><td><code>i1</code></td><td> </td><td width=10> </td><td>Initial value of index (default: 1).</td></tr>
<tr><td width=20></td><td><code>i2</code></td><td> </td><td width=10> </td><td>Terminal value of index (default: size of the converted table of <code>x</code>).</td></tr>
<tr><td width=20></td><td><code>s</code></td><td> </td><td width=10> </td><td>Step size (default: 1).</td></tr>
</tbody></table>
<pre><code>
mathly = require('mathly')
a = mathly{{52, 67, 82}, {82, 15, 70}, {94, 82, 50}}
display(tt(a))
-- {52, 82, 94, 67, 15, 82, 82, 70, 50}
display(tt(a, 3, 1000)) -- or display(tt(a, 3))
-- {94, 67, 15, 82, 82, 70, 50}
x = tt(a, 3)
display(tt(x, 1, 1000, 2)) -- 1000? any value larger than the actual size of a table is replaced with the size of the table.
-- {94, 15, 82, 50}

x = {{1}, {2}, {3}, {4}, {5}}
display(tt(x))
-- {1, 2, 3, 4, 5}
display(tt(x, 1, 4, 2))
-- {1, 3}

x = {1, 2, {3}, 4, {{5, 6, {7}}}}
display(tt(x))
-- {1, 2, 3, 4, 5, 6, 7}
display(tt(x, 2, 4))
-- {2, 3, 4}
display(subtable(x, 2, 4))
-- {2, {3}, 4}
display(tt(x, 2))
-- {2, 3, 4, 5, 6, 7}
display(tt(x, 2, 6, 3))
-- {2, 5}
</code></pre>
<h4>&bull; &nbsp; <a name=expand href=#mathly><code>expand(A, m, n, v)</code></a></h4>
<p>Return an expanded/shrinked mathly matrix with value v's added or entries dropped.</p>
<p>The default value of <code>v</code> is 0, and the default value of <code>n</code> is <code>m</code>.</p>
<pre><code>
mathly = require('mathly')
a = mathly{{52, 67, 82}, {82, 15, 70}, {94, 82, 50}}
disp(a)
-- 52  67  82
-- 82  15  70
-- 94  82  50
disp(expand(a, 2, 4))
-- 52  67  82  0
-- 82  15  70  0
disp(expand(a, 4, 5, -1))
-- 52  67  82  -1 -1
-- 82  15  70  -1 -1
-- 94  82  50  -1 -1
-- -1  -1  -1  -1 -1
disp(expand(a, 2))
-- 52  67
-- 82  15
</code></pre>
<h4>&bull; &nbsp; <a name=repmat href=#mathly><code>repmat(A, m, n)</code></a></h4>
<p>Return a mxn block matrix with each entry a copy of matrix <code>A</code>. The default value of <code>n</code> is <code>m</code>.</p>
<pre><code>
mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}
disp(a)
-- 1  2  3
-- 2  3  4
disp(repmat(a, 2))
-- 1  2  3  1  2  3
-- 2  3  4  2  3  4
-- 1  2  3  1  2  3
-- 2  3  4  2  3  4
disp(repmat(a, 2, 3))
-- 1  2  3  1  2  3  1  2  3
-- 2  3  4  2  3  4  2  3  4
-- 1  2  3  1  2  3  1  2  3
-- 2  3  4  2  3  4  2  3  4
disp(repmat(5, 2, 3)) -- same as mathly(2, 3, 5)
-- 5  5  5
-- 5  5  5
</code></pre>
<h4>&bull; &nbsp; <a name=fliplr></a><a name=flipud href=#mathly><code>flipud(A), fliplr</code></a></h4>
<ol>
<li>flipud(A): Return a matrix with rows of matrix <code>A</code> reversed. (ud: upside down)</li>
<li>fliplr(A): Return a matrix with columns of matrix <code>A</code> reversed. (lr: from left to right) </li>
</ol>
<pre><code>
mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}
disp(a)
-- 1  2  3
-- 2  3  4
disp(flipud(a))
-- 2  3  4
-- 1  2  3
disp(fliplr(a))
-- 3  2  1
-- 4  3  2
</code></pre>
</div>
<h4>&bull; &nbsp; <a name=lu href=#mathly><code>lu(A)</code></a></h4>
<p>Return <code>L</code> and <code>U</code> of LU factorization <code>A = LU</code>, where <code>L</code> and <code>U</code> are lower and upper triangular matrices, respectively.</p>
<pre><code>
mathly = require('mathly')
A = mathly{{1, 2, 3}, {2, 3, 4}, {-1, 0, 2}}
L, U = lu(A)
disp(L)
--  1   0  0
--  2  -1  0
-- -1   2  1
disp(U)
-- 1  2  3
-- 0  1  2
-- 0  0  1
disp(L * U - A)
-- 0  0  0
-- 0  0  0
-- 0  0  0
</code></pre>
<h4>&bull; &nbsp; <a name=qr href=#mathly><code>qr(A)</code></a></h4>
<p>Return <code>Q</code> and <code>R</code> of QR factorization <code>A = QR</code>, where <code>A</code> is a <code>mxn</code> matrix, <code>Q</code> is a <code>mxn</code> matrix with orthonormal
column vectors, and <code>R</code> is an invertible upper triangular <code>nxn</code> matrix.</p>
<p>Note: mathly applies the Gram-Schmidt process and requires that <code>m &ge; n</code>.
<pre><code>
mathly = require('mathly')
A = mathly{{1, 2, 3}, {2, 3, 4}, {-1, 0, 2}}
Q, R = qr(A)
disp(Q)
--  0.4082  0.4364  -0.8018
--  0.8165  0.2182   0.5345
-- -0.4082  0.8729   0.2673
disp(R)
-- 2.4495  3.2660  3.6742
--      0  1.5275  3.9280
--      0       0  0.2673
disp(Q * R - A)
--  0.0000   0.0000   0.0000
--  0.0000   0.0000  -0.0000
-- -0.0000  -0.0000  -0.0000
</code></pre>
<h4>&bull; &nbsp; <a name=remake href=#mathly><code>remake(A, opt)</code></a></h4>
<p>Generate a lower (opt = 'LT'), upper (opt = 'UT'), diagonal (opt = 'DIAG'), or symmetrical (opt = 'SYM') matrix from matrix <code>A</code>.</p>
<p>If, say, <code>opt = {k<sub>1</sub>, k<sub>2</sub>, ..., k<sub>m</sub>}</code>, generate from matrix <code>A</code> a matrix which keeps the diagonal entries <code>k<sub>i</sub></code> rows above (<code>k<sub>i</sub> > 0</code>) or <code>-k<sub>i</sub></code> rows below (<code>k<sub>i</sub> < 0</code>) the main diagonal, <code>i = 1, 2, ..., m</code>.</p>
<pre><code>
mathly = require('mathly')
A = reshape(seq(1, 25), 5, 5)
disp(A)
-- 1   6  11  16  21
-- 2   7  12  17  22
-- 3   8  13  18  23
-- 4   9  14  19  24
-- 5  10  15  20  25
remake(A, 'UT')
-- 1   6  11  16  21
-- 0   7  12  17  22
-- 0   0  13  18  23
-- 0   0  0   19  24
-- 0   0  0   0   25
remake(A, 'SYM')
-- 1   6  11  16  21
-- 6   7  12  17  22
-- 11  12 13  18  23
-- 16  17 18  19  24
-- 21  22 23  24  25
remake(A, {-1, 0, 1}) -- or remake(A, seq(-1,1)) -- See also: <a name=remake1></a><a href=#diag1>diag</a>
-- 1  6   0   0   0
-- 2  7  12   0   0
-- 0  8  13  18   0
-- 0  0  14  19  24
-- 0  0   0  20  25
remake(A, {-1, seq(1,3)})
-- 0  6  11  16   0
-- 2  0  12  17  22
-- 0  8   0  18  23
-- 0  0  14   0  24
-- 0  0   0  20   0
remake(randi({-100, 100}, 6), 'LT') -- generate randomly a lower triangular matrix
</code></pre>
<h4>&bull; &nbsp; <a name=unique href=#mathly><code>unique(tbl)</code></a></h4>
<p>Return the same data as in tbl but with no repetitions. Data is sorted.</p>
<pre><code>
require('mathly')
display(unique({4,5,2,1,-2,2,4,2,7,6,19}))
-- {-2, 1, 2, 4, 5, 6, 7, 19}
</code></pre>
<h4>&bull; &nbsp; <a name=strcat href=#mathly><code>strcat(...)</code></a></h4>
<p>Horizontally concatenate input strings and return the resulted string.</p>
<p>See also: <a href=#tblcat><code>tblcat</code></a></p>
<pre><code>
require('mathly')
print(strcat('Good', ' ', 'morning', '!'))
-- Good morning!
</code></pre>
<h4>&bull; &nbsp; <a name=mean href=#mathly><code>mean(x)</code></a></h4>
<ol>
<li>If <code>x</code> is a table or mathly row/column vector, return the mean of its elements;</li>
<li>If <code>x</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the mean of
the <code>i</code>-th column of <code>x</code>.</p></li>
</ol>
<pre><code>
mathly = require('mathly')
disp(mean({1,2,3}))
-- 2
A = mathly{{1, 2, 3}, {2, 3, 4}, {3, 1, 2}}
disp(A)
-- 1  2  3
-- 2  3  4
-- 3  1  2
disp(mean(A))
-- 2  2  3
print(mean('abc')) -- 'abc' --> {97, 98, 99}, string.byte('a') ...
-- 98.0
print(mean({'abc', 'de'})) --> strcat first: 'abcde' --> mean('abcde')
-- 99.0
</code></pre>
<h4>&bull; &nbsp; <a name=var></a><a name=std href=#mathly><code>std(x, opt)</code>, <code>var(x, opt)</code></a></h4>
<ol>
<li>If <code>x</code> is a table or mathly row/column vector, return the standard deviation of its elements;</li>
<li>If <code>x</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the standard deviation of
the <code>i</code>-th column of <code>x</code>.</p></li>
</ol>
<p>If <code>opt = 0</code> (default), calculate for a population; otherwise, calculate for a sample.</p>
<pre><code>
mathly = require('mathly')
disp(std({1,2,3}))
-- 1
disp(std({1,2,3}, 1))
-- 0.8165
A = mathly{{1, 2, 3}, {2, 3, 4}, {4, 7, 9}}
disp(A)
-- 1  2  3
-- 2  3  4
-- 4  7  9
disp(std(A))
-- 1.5275  2.6458  3.2146
disp(var(A))
-- 2.3333  7  10.3333
disp(var(A, 1))
-- 1.5556  4.6667  6.8889
</code></pre>
<h4>&bull; &nbsp; <a name=format href=#mathly><code>format(fmt)</code></a></h4>
<p>Reset or specify the format of the output of <code>disp(...)</code>. <code>fmt</code> can be any of the following options.</p>
<table><tbody>
<tr><td width=20></td><td><code>'bank'</code></td><td> </td><td width=10> </td><td>2 decimal places</td></tr>
<tr><td width=20></td><td><code>'short'</code></td><td> </td><td width=10> </td><td>4 decimal places (default).</td></tr>
<tr><td width=20></td><td><code>'long'</code></td><td> </td><td width=10> </td><td>15 decimal places</td></tr>
</tbody></table>
<h4>&bull; &nbsp; <a name=what></a><a name=filter href=#mathly><code>filter(A, f)</code>, <code>what(A, B)</code></a></h4>
<p>The two functions are usually used together.</p>
<ol>
<li><code>filter(A, f)</code>: Check if each element of matrix <code>A</code> makes <code>f(x)</code> true or not, return 1 or 0 for the element.</li><p></p>
<li><code>what(A, B)</code>: Return a column vector of elements of <code>A</code> columnwisely if the corresponding element in <code>B</code> is 1.</li>
</ol>
<p>Note: <code>f(x)</code> returns true or false (default: <code>x ~= 0</code>).</p></li>
<pre><code>
mathly = require('mathly')
A = mathly{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
disp(A)
- 1  2  3
- 4  5  6
- 7  8  9
C = filter(A, function(x) return x >= 2 and x % 2 == 0 end)
disp(C)
-- 0  1  0
-- 1  0  1
-- 0  1  0
B = what(A, C)
disp(B)
-- 4
-- 2
-- 8
-- 6
</code></pre>
<hr>
<h2 style="margin-left: 20px;">Note</h2>
<ol>
<li>Most functions provided in this mathly module, e.g., <code>copy</code>, <code>disp</code>, and
<code>display</code>, can't be applied to tables like <code>x = {1, 2, age=20, 10, year=2024}</code> with
fields, i.e., <code>age</code> and <code>year</code> in the example. It is designed simply for numerical computing.</li>
<p></p>
<li>This project was started first right in the downloaded code of the Lua module, matrix.lua, found
in <a href="https://github.com/davidm/lua-matrix/blob/master/lua/matrix.lua">https://github.com/davidm/lua-matrix/blob/master/lua/matrix.lua</a>, to see if Lua is good for
numerical computing. However, it failed to solve numerically a boundary value problem. The solution
was obviously wrong because the boundary condition at one endpoint is not satisfied, but I could not find
anything wrong in both the algorithm and the code. I had to wonder if there were bugs in the module. In many
cases, it is easier to start a small project from scratch than using and debugging others' code. In
addition, matrix.lua addresses a column vector like a[i][1] and a row vector a[1][i], rather than a[i]
in both cases, which is quite ugly and unnatural. Furthermore, basic plotting utility is not provided in
matrix.lua. Therefore, this mathly module was developed. But anyway, I appreciate the work in matrix.lua.
Actually, you may find some similarities in the code of matrix.lua and mathly.lua, e.g., m1, m2 are used
to name arguments of some functions.</li>
</ol>
<p style="margin-left: 40px;">December 25, 2024</p>
</div>
</body>
</html>

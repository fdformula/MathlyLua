<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<style>
a { text-decoration: none; }
p { margin: 20px }
div { font-size: 16px; margin: 30px 20px }
table, pre { margin: 1px 25px }
table.numberedRows { counter-reset: rowNum } /* https://forums.madcapsoftware.com/viewtopic.php?t=27293 */
table.numberedRows tbody tr { counter-increment: rowNum }
table.numberedRows tbody tr td:first-child::before { content: counter(rowNum) }
</style>
</head>
<body>
<div>
<h2><a name=top></a><a href=#m>Mathly Turns Lua into a Tiny but Powerful MATLAB</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &rArr; <a href=lua5_4.html>Lua 5.4 Manual</a></h2>
<ol>
<li><a href=#intro>Introduction</a></li>
<li><a href=#version>Which version of Lua is needed?</a></li>
<li><a href=#where>Where to place the downloaded files of this module?</a></li>
<li><a href=#twothings>Two important things you need to know</a></li>
<li><a href=#math>Basic mathematical functions and elementwise operations</a></li>
<li><a href=#m>Table of other functions</a></li>
</ol>
<h2><a name=intro></a>Introduction</h2>
<p>Mathly for <a href=https://www.lua.org>Lua</a> is a Lua module which turns Lua into a tiny but powerful MATLAB. It provides a group of commonly used MATLAB functions and features,
for example, <code>linspace</code>, <code>zeros</code>, <code>rand</code>, <code>save</code>, convenient matrix operations, and even
<code>plot</code>. They make coding and testing a thought/algorithm much easier and faster than working in most other
programming languages. If there is anything many love the most about MATLAB, these tools are.</p>

<p>Mathly uses Plotly JavaScript graphing tools (see <a href="https://plotly.com/javascript/">https://plotly.com/javascript/</a>)
to plot graphs of single-variable functions. Therefore, graphs are shown in an internet browser.</p>

<p>The entire mathly tool together with Lua is less than 5 MB, while providing enough features for instructors and
college students to introduce and/or implement many numerical algorithms. Because it is super lightweight and fast as well,
it can be employed to slow devices like an old Microsoft Surface Pro 4. Imagine that the smallest size of GNU Octave
is about 300 MB, MATLAB needs a few GB storage space, and Julia with graphing modules is huge, too. You can hardly
install them on a quite old computer and run smoothly.</p>

<p>Mathly is especially good for instructors of linear algebra and numerical computing for teaching. It takes no time to
start Lua and load mathly. While developing code and doing computation in a lecture, they can simply focus on delivery
of course contents and never need to worry if their computers work too slowly or even collapse. Besides, an extra benefit
of using Lua is that Lua is so simple and natural a language that even students without programming skills can understand most
of Lua scripts.</p>

<h2><a name=version></a>Which version of Lua is needed?</h2>
<p>Mathly is developed in Lua 5.4.6. It works with the present newest version 5.4.7. It might work with previous versions.</p>
<p>You may download Lua source code in <a href="https://lua.org/">https://lua.org/</a> and compile it yourself or simply
download prebuilt binary commands for Microsoft Windows in, say,
<a href="https://www.nuget.org/packages/lua/">https://www.nuget.org/packages/lua/</a>. Another way to get prebuilt Lua is to
download <a href=https://studio.zerobrane.com/>ZeroBrane Studio</a>, a lightweight Lua IDE for various platforms. It may come with
multiple versions of Lua.</p>
<p>Microsoft Windows users may download the file <a href=https://github.com/fdformula/MathlyLua><code>cudatext-for-mathly-win-*.7z</code></a>, including
Lua 5.4.6. Run <a href=https://7-zip.org/>7zip</a> to extract it to <code>C:/</code> . <a href=https://cudatext.github.io/>CudaText</a> is a very good "IDE" for
Lua and running mathly as well. Quite a few CudaText plugins are included. Some are customized and even have new features added.
While in CudaText, press</p>
<pre><code>  F1               to open help document on current Lua/mathly function

  F2               to start Lua with mathly loaded
  Ctrl-,           to run Lua command on current line in the editor
  Ctrl-.           to run all Lua script in the editor (HTML file? open it in a browser)

  Ctrl-Alt-Space   to trigger auto lexical completion
  Shift-Alt-Space  to trigger auto text completion (Ctrl-p d, load an English dictionary as part of the text)
</code></pre>
<p><code>F2</code>, <code>Ctrl-,</code>, and <code>Ctrl-.</code> work with Bash, Julia, Octave, Python, R, Ruby, and some other
languages with interactive REPL terminal. CudaText detects and selects the very language
according to the extension of the present filename (defaults to Lua). See: The first few
lines of the file, <code>C:\cygwin\cudatext\py\cuda_ex_terminal\__init__.py</code>.</p>

<p>Other hotkeys? Refer to <code>C:\cygwin\cudatext\cudatext-hotkeys-for-plugins.txt</code>.</p>

<h2><a name=where></a>Where to place the downloaded files of this module?</h2>
<p>They can be placed in either</p>
<ol>
<li>the folder of your Lua code files to run/test or</li>
<li>(Windows) the folder, e.g., <code>c:/cygwin/bin/</code>, which contains the command, <code>lua.exe</code>:
<pre><code>...
lua.exe
browser-setting.lua
mathly.lua
plotly-2.9.0.min.js
...
</code></pre><p></p>
(Linux) <code>/usr/local/share/lua/5.4/</code>
</li></ol>
<p><em>You may need to edit the file <code>browser-setting.lua</code>.</em> See comments in the very file.</p>
<p>&#x2713; &nbsp; The <code>*.lua</code> files can be compiled with <code>luac</code>. To use compiled modules, we set
<code>package.path</code> first as follows:</p>
<p><code>package.path = "./?.luac;;"</code></p>

<h2><a name=twothings></a>Two important things you need to know</h2>

<p><B>1. The difference between Lua tables and mathly matrices</B></p>
<p>Tables are the only data structure Lua offers. However, we may use it as arrays, vectors, matrices, dictionaries, and
so on. For example, <code>{}</code>, <code>{'ab'}</code>, <code>{1, 2, 3}</code>, <code>{{1, 2, 3}, {1, 2, 3, 4}}</code>,
<code>{1, 'ab', { 2, 3, {4}}}</code>, <code>{layout={width=900, height=400, grid={rows=2, columns=2}, title='Demo'}</code>
are all tables.</p>

<p><b>A mathly matrix is obtained/generated</b> by mathly 'constructor', functions like <code>zeros</code>, <code>ones</code>,
<code>rand</code>, <code>randi</code>, <code>reshape</code>, <code>submatrix</code>, <code>cc</code>, <code>rr</code>, or
matrix operations like <code>A^T</code>, <code>inv(A)</code>, <code>rref(B)</code>, and
<code>2 * A  - 3 * B + 4</code>, given that <code>A</code> and <code>B</code> are <code>nxn</code> mathly matrices. An element in the
<code>i</code>th row and <code>j</code>th column is addressed as <code>A[i][j]</code>.</p>

<p>Simply speaking, a mathly matrix is a table (of tables), but a table may not be a mathly matrix.</p>

<p><B>2. We can only apply matrix operations on mathly matrices; if an operation involves two objects, at least one must be a mathly matrix.</b>
To apply matrix operations on ordinary Lua tables, conversion is needed and done first through mathly 'constructor',
<code>cc</code>, <code>rr</code>, or <code>reshape</code>. For example,</p>
<pre><code>mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}   -- a, b, c, d, A, B, C, D, and E are all mathly matrices
b = {{1}, {2}, {3}}; b = mathly(b) -- or b = cc{1, 2, 3}
c = mathly(1, 10, 5)
d = mathly(1, 10, 0)      --  same as f = mathly(zeros(1, 10))
A = mathly(10, 10)
B = mathly(1, 10)
C = randi(100, 10, 1)     -- a column vector of random integer numbers (from 1 to 100)
D = rand(10, 2)           -- a 10x2 matrix of random numbers (from 0 to 1)
E = reshape(C, 3)         -- a 3x4 matrix; 4 is determined by mathly

3*a - 10
2*c + 5 * d - 3
-- inv(A) * B             -- not allowed as in math
inv(A) * B^T
inv(A) * randi(50, 1, 10) -- mathly knows how to handle a Lua table
randi(50, 1, 10) * inv(A) -- randi(50, 1, 10) here in its context

A = randi(100, 10, 5)
B = randi(100, 5, 3)
C = rand(3, 1)
A - 2
A * B
A * B * C
B * C
C^T * B^T

A = randi(100, 4)
B = randi(50, 4)
C = 3 * A - 4 * B + 5
A^2

x = linspace(0, pi, 10)   -- x, y, and z are not mathly matrices/vectors.
y = cos(x)
z = sin(x)

-- 3 * y                  -- not allowed/defined
-- y + z                  -- not allowed/defined
mathly(y) + z             -- y + mathly(z), or mathly(y) + mathly(z) -- at least one must be a mathly matrix
2*rr(y) - 3 * rr(z)       -- both y and z must be converted to mathly matrices

x = {1, 2, 3}
rr(x)^2
rr(x) * x                 -- x * cc(x), or rr(x) * cc(x) -- mathly tries to convert a table to a row/column
cc(x) * x                 -- vector according to the context

rr(x) * rr(x)             -- the product of two row (or column) vectors is like x .* y in MATLAB
cc(x) * cc(x)             --

Y = mathly(y)
display(y)
display(Y)                -- print a table of any type, including a mathly matrix, with structure
disp(Y)                   -- print a mathly matrix

A = randi({-10,10}, 4); B = copy(A); C = copy(A)
rref(A)                   -- warn: A and B are modified (for performance)
inv(B)                    --
inv(submatrix(C, 1, 1, 3, 3))

-- matrix/table "division" is elementwise, provided for convenience only
x = {1, 2, 3, 4, 5}
rr(x) / 10
--  0.1000  0.2000  0.3000  0.4000  0.5000
1 / (2 * rr(x) + 1)
--  0.3333  0.2000  0.1429  0.1111  0.0909

y = 2 * cc(x) + 1
disp(y^T)
--  3   5   7   9  11
(x / y)^T
--  0.3333  0.4000  0.4286  0.4444  0.4545
A = mathly{{1, 2}, {3, 4}}
--  1  2
--  3  4
{{2, 3}, {4, 5}} / A
-- 2.0000  1.5000
-- 1.3333  1.2500
</code></pre>

<p>A mathly row vector is a <code>1xn</code> mathly matrix, and a mathly column vector is a <code>nx1</code> mathly matrix.
They are all matrices and, thus, an element must be addressed like <code>A[1][i]</code> (for a row vector) or <code>A[i][1]</code>
(for a column vector), which is inconvenient and ugly because we human beings never write this way!</p>

<p><i>Mathly tries its best to allow us to write math expressions as we do on paper.</i> Therefore, <code>ones</code>,
<code>zeros</code>, <code>rand</code> and <code>randi</code> generate each a table rather than a mathly matrix if
used this way, say, <code>ones(1, 100)</code>. This allows us to generate a table of specified length and
address it conveniently like <code>x[i]</code> instead of <code>x[1][i]</code>. This is also why functions like
<code>linspace</code>, <code>seq</code>, and <code>range</code> all generate a table rather than a mathly row/column vector.

<p>If you want full control, you can use <code>cc</code> or <code>rr</code> to convert an ordinary table to a column
or row vector. (See <a href=#cc><code>cc(x...)</code>, <code>rr(x...)</code>, <code>tt(x...)</code></a>)</p>

<h2><a name=math></a>Basic mathematical functions and elementwise operations</h2>
<p>&#x2713; &nbsp; Basic mathematical functions</p>
<p>Basic math functions are each now able to work <em>elementwisely</em> on Lua tables, including mathly matrices. They are
<code>abs</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>ceil</code>, <code>cos</code>,
<code>deg</code>, <code>exp</code>, <code>floor</code>, <code>log</code>, <code>rad</code>, <code>random</code>,
<code>sin</code>, <code>sqrt</code>, and <code>tan</code>. They evaluate a function at every number in a
table and keep the structure of the table.</p>
<pre><code>require('mathly')
A = randi(100, 5, 6)
disp(cos(A))

x = {-1, 2, -3, {4, -5, {6}}}
disp(abs(x))
-- {1, 2, 3, {4, 5, {6}}}
disp(log(abs(x)))
</code></pre>

<p>&#x2713; &nbsp; With each of these functions, should we use, say, <code>sin(x)</code> or <code>math.sin(x)</code>?
<B>You can always use <code>sin(x)</code>. However, if you know <code>x</code> is a number, you may call
<code>math.sin(x)</code> to get a little improvement in performance.</p></B>

<p>&#x2713; &nbsp; Other elementwise operations
<p>Let <code>x</code> and <code>y</code> be two tables of the same size. Then, <a href=#cc><code>cc(x) * cc(y)</code></a> or
<a href=#cc><code>rr(x) * rr(y)</code></a> functions like <code>x .* y</code> in MATLAB. As per other cases or actually all cases, we
can do elementwise operations, simple or complicated, through <a href=#map><code>map</code></a>.
<pre><code>mathly = require('mathly')
A = randi(100, 5, 7)  -- A, B can be any tables of numbers
B = randi(100, 5, 7)
C = map(function(x, y) return x * y end, A, B) -- A .* B
disp(C)
C = map(function(x, y) return x / y end, A, B) -- A ./ B
disp(C)
disp(map(function(x) return x ^ 2 end, A))     -- A .^ 2

D = map(function(x, y, z)
          if iseven(x) then
            return x - y + 3 * z
          else
            return x + y * y
          end
        end, A, B, C)
disp(D)
</code></pre>

<p>&#x2713; &nbsp; <a name=div></a><a name=mod></a>Functions <code>div</code> and <code>mod</code> are simply the names of <a href=manual.html#3.4.1>Lua operators <code>//</code> and <code>%</code></a>, respectively.
They make Lua code more understandable to people who are new to Lua. They follow the definition: if <code>d &gt; 0</code>, <code>r = mod(a, d)</code> is the remainder of <code>a</code>
divided by <code>d</code> with <code>0 &le; r &lt; d</code> while <code>div(a, d)</code> gives the quotient.</p>

<p>In addition, mathly provides four commonly used constants:</p>
<table><tbody>
<tr><td><code>pi = 3.1415926535898</code></td><td width=40></td><td>It is simply <code>math.pi</code>.</td></tr>
<tr><td><code>e = 2.718281828459</code></td><td width=40></td><td>It is <code>math.exp(1)</code>.</td></tr>
<tr><td><code>eps = 2.220446049250313e-16</code></td><td width=40></td><td>It is the machine epsilon, i.e., the smallest difference between any two numbers.</td></tr>
<tr><td><code>phi = 1.6180339887499</code></td><td width=40></td><td>It is the golden ratio, <code>(1 + math.sqrt(5)) / 2</code>.</td></tr>
</tbody>
</table>
<p></p>
<p><u>Note</u>: <code>T</code> is reserved by mathly for finding the transpose of a matrix, e.g., <code>A^T</code>, where <code>A</code> is a mathly matrix.</p>

<a name=m></a><h2><a href=#top>The following table summarizes other functions provided by <code>mathly</code>.</a></h2>
<table class="numberedRows">
<tbody>
<tr><td> </td><td width="25%"><a href=#all><code>all(x, f)</code></a></td><td width=1%> </td><td width=74%>Test if <code>f(x)</code> is true for every number in <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#any><code>any(x, f)</code></a></td><td> </td><td>Test if there is any number in <code>x</code> such that <code>f(x)</code> is true.</td></tr>
<tr><td> </td><td><a href=#apply><code>apply(f, ...)</code></a></td><td> </td><td>As with some other programming languages like <i>Mathematica</i>, call function <code>f</code> with the arguments.</td></tr>
<tr><td> </td><td><a href=#arc><code>arc(r, center, angles, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot an arc of a circle.</td></tr>
<tr><td> </td><td><a href=#boxplot><code>boxplot(x, names)</code></a></td><td> </td><td>Return a special graph object for <code><a href=#plot>plot</a></code> to plot a box plot (or box-and-whisker plot), where <code>x</code> is a table or a matrix of numbers. <code>names = {'name1', 'name2', ...}</code> is optional.</td></tr>
<tr><td> </td><td><a href=#cc><code>cc(x...)</code></a></td><td> </td><td>Convert table <code>x</code> into a column vector or return specified column(s) of a mathly matrix...</td></tr>
<tr><td> </td><td><a href=#circle><code>circle(r, center, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a circle.</td></tr>
<tr><td> </td><td><code>clc()</code></td><td> </td><td>Clear Lua console.</td></tr>
<tr><td> </td><td><code>clear()</code></td><td> </td><td>Delete all user-defined variables and their values in memory and make it ready for a new task.</td></tr>
<tr><td> </td><td><a href=#copy><code>copy(x)</code></a></td><td> </td><td>Make a deep copy of <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#cross><code>cross(a, b)</code></a></td><td> </td><td>Calculate the cross/vector product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>}</code> and <code>b = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>}</code>.</td></tr>
<tr><td> </td><td><a href=#demathly><code>demathly(x)</code></a></td><td> </td><td>Force <code>x</code> not to be a mathly matrix.</td></tr>
<tr><td> </td><td><code>det(A)</code></td><td> </td><td>Calculate the determinant of square matrix <code>A</code>. <u>Note</u>: A is modified.</td></tr>
<tr><td> </td><td><a href=#diag><code>diag(A, ...)</code></a></td><td> </td><td>Return a column vector consisting of specified diagonal entries of mathly matrix <code>A</code> or create a mathly matrix with vector <code>A</code> as its diagonal entries.</td></tr>
<tr><td> </td><td><a href=#disp><code>disp(x)</code></a></td><td> </td><td>Print a mathly matrix.</td></tr>
<tr><td> </td><td><a href=#display><code>display(x)</code></a></td><td> </td><td>Print a table of any type, including mathly matrices, with structure.</td></tr>
<tr><td> </td><td><a href=#dot><code>dot(a, b)</code></a></td><td> </td><td>Calculate the dot/inner product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>}</code> and <code>b = {b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub>}</code>.</td></tr>
<tr><td> </td><td><a href=#eval><code>eval(str)</code></a></td><td> </td><td>Evaluate the expression in <code>str</code> and return the result.</td></tr>
<tr><td> </td><td><a href=#expand><code>expand(A, m, n, v)</code></a></td><td> </td><td>Return an expanded/shrunk <code>mxn</code> mathly matrix with value <code>v</code>'s added or entries dropped.</td></tr>
<tr><td> </td><td><code>eye(n)</code></td><td> </td><td>Return a <code>nxn</code> identity mathly matrix.</td></tr>
<tr><td> </td><td><a href=#flatten><code>flatten(x)</code></a></td><td> </td><td>Remove the structure of <code>x</code> and return a table of all atomic elements in <code>x</code> in order.</td></tr>
<tr><td> </td><td><a href=#fliplr><code>fliplr(A)</code></a></td><td> </td><td>Return a matrix with columns of matrix <code>A</code> reversed.</td></tr>
<tr><td> </td><td><a href=#flipud><code>flipud(A)</code></a></td><td> </td><td>Return a matrix with rows of matrix <code>A</code> reversed.</td></tr>
<tr><td> </td><td><a href=#format><code>format(fmt)</code></a></td><td> </td><td>Reset or specify the format of the output of <code>disp(...)</code>.</td></tr>
<tr><td> </td><td><a href=#freqpolygon><code>freqpolygon(x, nbins, style, xrange)</code></a></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot frequency polygon, where <code>x</code> is a table of numbers.</td></tr>
<tr><td> </td><td><a href=#hasindex><code>hasindex(tbl, index)</code></a></td><td> </td><td>Check if table <code>tbl</code> contains <code>index</code>.</td></tr>
<tr><td> </td><td><a href=#hist><code>hist(x, nbins, style, xrange)</code></a></td><td> </td><td>Return a special graph object for <code><a href=#plot>plot</a></code> to plot a histogram, where <code>x</code> is a table or a matrix of numbers and <code>nbins</code> is the number of bins (default: 10).</td></tr>
<tr><td> </td><td><a href=#hist1><code>hist1(x, nbins, style, xrange)</code></a></td><td> </td><td>Return an ordinary graph object for <code><a href=#plot>plot</a></code> to plot a histogram, where <code>x</code> is a table of numbers.</td></tr>
<tr><td> </td><td><a href=#histfreqpolygon><code>histfreqpolygon(x, nbins, style, xrange, style1)</code></a></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a histogram plus a frequency polygon, where <code>x</code> is a table of numbers.</td></tr>
<tr><td> </td><td><a href=#horzcat><code>horzcat(A, B, ...)</code></a></td><td> </td><td>Concatenate matrices <code>A</code>, <code>B</code>, ... in order horizontally. Matrices must have the same number of rows.</td></tr>
<tr><td> </td><td><a href=#input><code>input(prompt, s)</code></a></td><td> </td><td>Input from keyboard, return a string (if <code>s = 's'</code>); otherwise, evaluate the input expression, and return the result.</td></tr>
<tr><td> </td><td><a href=#inv><code>inv(A)</code></a></td><td> </td><td>Return the inverse of square mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</td></tr>
<tr><td> </td><td><code>isinteger(x)</code></td><td> </td><td>Check if <code>x</code> is an integer.</td></tr>
<tr><td> </td><td><code>iseven(x)</code></a></td><td> </td><td>Check if <code>x</code> is even.</td></tr>
<tr><td> </td><td><code>isodd(x)</code></a></td><td> </td><td>Check if <code>x</code> is odd.</td></tr>
<tr><td> </td><td><a href=#ismember><code>ismember(x, table)</code></a></td><td> </td><td>Check if <code>x</code> is a member of <code>table</code>.</td></tr>
<tr><td> </td><td><a href=#lagrangepoly><code>lagrangepoly(...)</code></a></td><td> </td><td>Return the Lagrange interpolating polynomial, defined by given data, or the values of the polynomial at specified points.</td></tr>
<tr><td> </td><td><code>length(x)</code></td><td> </td><td>Return the length of a table or string.</td></tr>
<tr><td> </td><td><a href=#line><code>line(point1, point2, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a straight line.</td></tr>
<tr><td> </td><td><a href=#linsolve><code>linsolve(A, b, opt)</code></a></td><td> </td><td>Solve a linear system <code>Ax = b</code> and return the solution. <u>Note</u>: Both <code>A</code> and <code>b</code> can be modified.</td></tr>
<tr><td> </td><td><a href=#linspace><code>linspace(x, y, n)</code></a></td><td> </td><td>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code> and ending at <code>y</code>.</td></tr>
<tr><td> </td><td><a href=#lu><code>lu(A)</code></a></td><td> </td><td>Return <code>L</code> and <code>U</code> of LU factorization <code>A = LU</code>.</td></tr>
<tr><td> </td><td><a href=#map><code>map(f, tbl1, tbl2, ...)</code></a></td><td> </td><td>Apply function <code>f</code> to each corresponding atomic element in tables, <code>tbl1, tbl2, ...</code>, and return the result.</td></tr>
<tr><td> </td><td><a href=#mathly><code>mathly(...)</code></a></td><td> </td><td>Constructor of mathly matrices.</td></tr>
<tr><td> </td><td><a href=#max><code>max(x)</code></a></td><td> </td><td>If <code>x</code> is a table/array, return the largest of all elements of the table; if it is a matrix, ...</td></tr>
<tr><td> </td><td><a href=#mean><code>mean(x)</code></a></td><td> </td><td>Return mean value of numbers in <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#min><code>min(x)</code></a></td><td> </td><td>If <code>x</code> is a table/array, return the smallest of all elements of the table; if it is a matrix, ...</td></tr>
<tr><td> </td><td><code>norm(x)</code></td><td> </td><td>Return the Euclidean norm of a row/column vector <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#ones><code>ones(m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 1. If <code>m = 1</code>, return a table.</td></tr>
<tr><td> </td><td><a href=#parametriccurve2d><code>parametriccurve2d({x(t), y(t)}, range, style, resolution)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a parametric curve.</td></tr>
<tr><td> </td><td><a href=#pareto><code>pareto(data, style, style1)</code></a></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a pareto chart.</td></tr>
<tr><td> </td><td><a href=#pie><code>pie(x, radius, nbins, style, offcenter, names)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a pie chart.</td></tr>
<tr><td> </td><td><a href=#plot><code>plot(x, y, ...)</code></a></td><td> </td><td>Plot the graph(s) of functions defined by data points <code>x</code> and <code>y</code> and ...</td></tr>
<tr><td> </td><td><a href=#plot3d><code>plot3d(f, xrange, yrange, title, resolution)</code></a></td><td> </td><td>Plot the 3D graph of <code>z = f(x, y)</code>.</td></tr>
<tr><td> </td><td><a href=#plotparametriccurve3d><code>plotparametriccurve3d({x(t), y(t), z(t)}, trange, titl, resolution)</code></a></td><td> </td><td>Plot a space curve defined by <code>{x(t), y(t), z(t)}</code>.</td></tr>
<tr><td> </td><td><a href=#plotparametricsurface3d><code>plotparametricsurface3d({x(u, v), y(u, v), z(u, v)}, urange, vrange, title, resolution)</code></a></td><td> </td><td>Plot a surface defined by <code>x = x(u, v), y = y(u, v), z = z(u, v)</code>.</td></tr>
<tr><td> </td><td><a href=#plotsphericalsurface3d><code>plotsphericalsurface3d(rho, thetarange, phirange, title, resolution)</code></a></td><td> </td><td>Plot a spherical function.</td></tr>
<tr><td> </td><td><a href=#point><code>point(x, y, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a point.</td></tr>
<tr><td> </td><td><a href=#polarcurve2d><code>polarcurve2d(r(t), range, style, resolution)</code></a></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a polar curve.</td></tr>
<tr><td> </td><td><a href=#polygon><code>polygon(vertices, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a polygon.</td></tr>
<tr><td> </td><td><a href=#polynomial><code>polynomial(...)</code></a></td><td> </td><td>Return the polynomial, defined by given data, or the values of the polynomial at specified points.</td></tr>
<tr><td> </td><td><a href=#polyval><code>polyval(coefs, x)</code></a></td><td> </td><td>Evaluate at <code>x</code> the value of a polynomial of which the coefficients are specified in a table <code>coefs</code>.</td></tr>
<tr><td> </td><td><a href=#printf><code>printf(...)</code></a></td><td> </td><td>Print formatted text like <code>printf</code> in C/C++.</td></tr>
<tr><td> </td><td><a href=#prod><code>prod(A)</code></a></td><td> </td><td>If <code>A</code> is a table or mathly row/column vector, return the product of its elements; if A is a <code>mxn</code> matrix, ...</td></tr>
<tr><td> </td><td><a href=#qr><code>qr(A)</code></a></td><td> </td><td>Return <code>Q</code> and <code>R</code> of QR factorization <code>A = QR</code>.</td></tr>
<tr><td> </td><td><a href=#rand><code>rand(m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> matrix of which each element is a random number in [0, 1]. If <code>m = 1</code>, return a table.</td></tr>
<tr><td> </td><td><a href=#randi><code>randi(...)</code></a></td><td> </td><td>Return a matrix of which each element is a random integer in a specified range.</td></tr>
<tr><td> </td><td><a href=#randn><code>randn(...)</code></a></td><td> </td><td>Return a matrix of normally distributed numbers.</td></tr>
<tr><td> </td><td><a href=#range><code>range(x, y, s)</code></a></td><td> </td><td>Return a table of numbers starting at <code>x</code>, in between <code>x</code> and <code>y</code>, and incrementing by <code>s</code>.</td></tr>
<tr><td> </td><td><code><a href=#remake>remake(A, opt)</a></code></td><td> </td><td>Generate a lower, upper, diagonal, symmetrical, or ...  matrix from matrix <code>A</code>.</td></tr>
<tr><td> </td><td><a href=#repmat><code>repmat(A, m, n)</code></a></td><td> </td><td>Return a <code>mxn</code> block matrix with each entry a copy of matrix <code>A</code>.</td></tr>
<tr><td> </td><td><a href=#reshape><code>reshape(A, m, n)</code></a></td><td> </td><td>Rearrange existing elements in a table or mathly matrix <code>A</code> and return a new <code>mxn</code> mathly matrix.</td></tr>
<tr><td> </td><td><a href=#reverse><code>reverse(tbl)</code></a></td><td> </td><td>Return a table with order of elements in table <code>tbl</code> reversed.</td></tr>
<tr><td> </td><td><a href=#round><code>round(x, n)</code></a></td><td> </td><td>Round <code>x</code> to <code>n</code> decimal places.</td></tr>
<tr><td> </td><td><a href=#rr><code>rr(x...)</code></a></td><td> </td><td>Convert table <code>x</code> into a row vector or return specified rows(s) of a mathly matrix...</td></tr>
<tr><td> </td><td><a href=#rref><code>rref(A, ...)</code></a></td><td> </td><td>Return the reduced row-echelon form of a mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</td></tr>
<tr><td> </td><td><a href=#save><code>save(datafile, ...)</code></a></td><td> </td><td>Save specified or all user-defined variables and their values to a Lua or MATLAB script file.</td></tr>
<tr><td> </td><td><a href=#scatter><code>scatter(x, y, style)</code></a></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a scatter plot.</td></tr>
<tr><td> </td><td><a href=#select><code>select(tbl, f)</code></a></td><td> </td><td>Return elements of table <code>tbl</code> that satisfy specified conditions.</td></tr>
<tr><td> </td><td><a href=#seq><code>seq(x, y, n)</code></a></td><td> </td><td>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code>, in <code>[x, y]</code>, ending at <code>y</code>.</td></tr>
<tr><td> </td><td><code>size(A)</code></td><td> </td><td>Return the dimensions of a mathly matrix <code>A</code>.</td></tr>
<tr><td> </td><td><a href=#sort><code>sort(tbl, compf)</code></a></td><td> </td><td>Sort table <code>tbl</code> and return the resulted table.</td></tr>
<tr><td> </td><td><a href=#printf><code>sprintf(...)</code></a></td><td> </td><td>Return a formatted string, while <code>printf</code> prints one.</td></tr>
<tr><td> </td><td><a href=#std><code>std(x, opt)</code></a></td><td> </td><td>Return the standard deviation of numbers in <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#strcat><code>strcat(...)</code></a></td><td> </td><td>Concatenate strings and return the resulted string.</td></tr>
<tr><td> </td><td><a href=#submatrix><code>submatrix(A, i, j, m, n, sr, sc)</code></a></td><td> </td><td>Return a mathly matrix, a block of mathly matrix <code>A</code>, starting at the <code>i</code>-th row and <code>j</code>-th column and ending at the <code>m</code>-th row and <code>n</code>-th column with row step <code>sr</code> and column step <code>sc</code>.</td></tr>
<tr><td> </td><td><a href=#subtable><code>subtable(tbl, i, j, s)</code></a></td><td> </td><td>Return a slice of table <code>tbl</code> starting from the <code>i</code>-th element to the <code>j</code>-th one with step size <code>s</code>.</td></tr>
<tr><td> </td><td><a href=#sum><code>sum(A)</code></a></td><td> </td><td>If <code>A</code> is a table or mathly row/column vector, return the sum of its elements; if A is a <code>mxn</code> matrix, ...</td></tr>
<tr><td> </td><td><a href=#tblcat><code>tblcat(t<sub>1</sub>, t<sub>2</sub>, ...)</code></a></td><td> </td><td>Flatten and concatenate tables into a single table. Tables here may just be numbers, boolean values, or strings.</td></tr>
<tr><td> </td><td><a href=#text><code>text(x, y, txt, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to write a text string on a graph.</td></tr>
<tr><td> </td><td><a href=#tic><code>tic()</code></a></td><td> </td><td>Start a wall-clock timer.</td></tr>
<tr><td> </td><td><a href=#toc><code>toc</code></a></td><td> </td><td>Print or return elapsed time on a wall-clock timer.</td></tr>
<tr><td> </td><td><code><a href=#cc>tt(x, i1, i2, s)</a></code></td><td> </td><td>Convert a mathly matrix to a table columnwisely or flatten any other table first and return a specified slice of the resulted table.</td></tr>
<tr><td> </td><td><a href=#unique><code>unique(tbl)</code></a></td><td> </td><td>Return the same data as in table <code>tbl</code> but with no repetitions.</td></tr>
<tr><td> </td><td><a href=#var><code>var(x, opt)</code></a></td><td> </td><td>Return the variance of numbers in <code>x</code>.</td></tr>
<tr><td> </td><td><a href=#vertcat><code>vertcat(A, B, ...)</code></a></td><td> </td><td>Concatenate matrices <code>A</code>, <code>B</code>, ... in order vertically. Matrices must have the same number of columns.</td></tr>
<tr><td> </td><td><a href=#wedge><code>wedge(r, center, angles, style)</code></a></td><td> </td><td>Return a graph object for <code>plot</code> to plot a wedge of a disk.</td></tr>
<tr><td> </td><td><code>who()</code></td><td> </td><td>List all user-defined variables in the memory.</td></tr>
<tr><td> </td><td><a href=#zeros><code>zeros</code></a></td><td> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 0. If <code>m = 1</code>, return a table.<hr></td></tr>

<tr><td> </td><td><a href=#axissquare><code>axissquare(), axisnotsquare()</code></a></td><td> </td><td>Force/stop a square axis aspect ratio. <b>Note</b>: This last group of functions are not valid for 3D graphs.</td></tr>
<tr><td> </td><td><a href=#showaxes><code>showaxes(), shownotaxes()</code></a></td><td> </td><td>Show/hide axes</td></tr>
<tr><td> </td><td><a href=#showxaxis><code>showxaxis(), shownotxaxis()</code></a></td><td> </td><td>Show/hide the <code>x</code>-axis</td></tr>
<tr><td> </td><td><a href=#showyaxis><code>showyaxis(), shownotyaxis</code></a></td><td> </td><td>Show/hide the <code>y</code>-axis</td></tr>
<tr><td> </td><td><a href=#showlegend><code>showlegend(), shownotlegend()</code></a></td><td> </td><td>Show/hide the legend</td></tr>
<tr><td> </td><td><a href=#showgridlines><code>showgridlines(), shownotgridlines()</code></a></td><td> </td><td>Show/hide gridlines</td></tr>
</tbody>
</table>

<h4>&bull; &nbsp; <a name=any></a><a name=all href=#m><code>all(x, f)</code>, <code>any(x, f)</code></a></h4>
<ol>
<li><code>all(x, f)</code>: Test if <code>f(x)</code> is true for every number in <code>x</code>.
<p>If <code>x</code> is a table or a row/column vector, returns 1 if all elements of the table make <code>f(x)</code> true.</p>
<p>If <code>x</code> is a mathly matrix, returns a row vector of 1's and 0's with each element indicating
if all of the elements of the corresponding column of the matrix make <code>f(x)</code> true.</p></li>

<li><code>any(x, f)</code>: Test if there is any number in <code>x</code> such that <code>f(x)</code> is true.
<p>If <code>x</code> is a mathly matrix, it returns a row vector of 1's and 0's with each element indicating
if there is any element of the corresponding column of the matrix which makes <code>f(x)</code> true.</p>
<p>If <code>x</code> is a simple table, a row or column vector, return 1 if there is any element of the table which makes <code>f(x)</code> true.</p>
<p style='margin: 1px 25px'>&#x2713; &nbsp; <code>f(x)</code> returns true or false (default: <code>x ~= 0</code>). It makes the two functions more useful than those in MATLAB.</p></li>
</ol>
<pre><code>mathly = require 'mathly'
A = mathly{{1, 2, 3}, {2, 3, 4}}
all(A, isinteger)
-- 1  1  1
any(A)
-- 1  1  1
any(A, function(x) return x > 2 end)
-- 0  1  1
x = {1, 2, 3, 4, 5, 6}
any(x, function(x) return x % 2 == 0 end)
-- 1
</code></pre>

<h4>&bull; &nbsp; <a name=apply href=#m><code>apply(f, ...)</code></a></h4>
<p>As with some other programming languages like <i>Mathematica</i>, it evaluates function <code>f</code> with provided arguments.</p>
<pre><code>require 'mathly'
function f(x, y, z) return x + y + z end
apply(f, {1, 2, 3})
-- 6
</code></pre>

<h4>&bull; &nbsp; <a name=round href=#m><code>round(x, n)</code></a></h4>
<p>Round <code>x</code> to <code>n</code> decimal places (default: 0).</p>
<pre><code>require('mathly')
a = mathly({{117.37826, 696.56562}, {594.53232, 636.11108}})
round(a)
-- 117  697
-- 595  636

round(a, 2)
-- 117.3800  696.5700
-- 594.5300  636.1100

round(pi, 4)
-- 3.1416
</code></pre>

<h4>&bull; &nbsp; <a name=cc></a><a name=rr></a><a name=tt href=#m><code>cc(x...)</code>, <code>rr(x...)</code>, <code>tt(x)</code></a></h4>
<p>A matrix operation may be applied to an ordinary table. It takes the table as a row or column vector according to the very context.
If you want full control, you can use <code>cc</code> or <code>rr</code> to tell mathly whether the table is a column or row vector.</p>
<table><tbody>
<tr><td width=20></td><td><code>cc(x...)</code></td><td> </td><td width=10> </td><td>Convert table <code>x</code> into a column vector or return specified columns of a mathly matrix...</td></tr>
<tr><td></td><td><code>rr(x...)</code></td><td> </td><td> </td><td>Convert table <code>x</code> into a row vector or return specified rows of a mathly matrix...</td></tr>
<tr><td></td><td><code>tt(x...)</code></td><td> </td><td> </td><td>Convert <code>x</code> to an ordinary table and return a slice of it.</td></tr>
</tbody></table>
<p>&#x2713; &nbsp; Why not <code>cc</code>, <code>rr</code>, and <code>tt</code>? It is because they can easily be used
as names of variables or so.</p>
<p>&#x2713; &nbsp; <code>rr</code> and <code>cc</code> have same usage, except that one is about row(s) and the other is about column(s). Take <code>rr</code> as an example:</p>
<table><tbody>
<tr><td width=20></td><td><code>rr(x)</code></td><td width=10></td><td>Convert <code>x</code> to a row vector.</td></tr>
<tr><td width=20></td><td><code>rr(A, i)</code></td><td></td><td>Return a row vector which is the <code>i</code>-th row of matrix <code>A</code>.</td></tr>
<tr><td width=20></td><td><code>rr(A, i, start, stop)</code></td><td></td><td>Return a row vector which is a slice of the <code>i</code>-th row of matrix <code>A</code> starting from column
<code>start</code> to <code>stop</code> (default: last column of <code>A</code>).</td></tr>
<tr><td width=20></td><td><code>rr(A, i, start, stop, step)</code></td><td></td><td>Return a row vector which is a slice of the <code>i</code>-th row of matrix <code>A</code> starting from column
<code>start</code> to <code>stop</code> increasing by <code>step</code>.</td></tr>
<tr><td width=20></td><td><code>rr(A, {i<sub>1</sub>, i<sub>2</sub>, ...}, start, stop)</code></td><td></td><td>Return a matrix consisting of rows <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>,
..., of <code>A</code>. Each row is a slice of the very row of <code>A</code> starting from column <code>start</code> to <code>stop</code> (default: last column of <code>A</code>).</td></tr>
<tr><td width=20></td><td><code>rr(A, {i<sub>1</sub>, i<sub>2</sub>, ...}, start, stop, step)</code></td><td></td><td>Return a matrix consisting of rows <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>,
..., of <code>A</code>. Each row is a slice of the very row of <code>A</code> starting from column <code>start</code> to <code>stop</code> increasing by <code>step</code></td></tr>
<p></p>
</tbody></table>
<b><p>Notes:</p></b>
<ol>
<li><code>i</code>, <code>i</code><sub>1</sub>, <code>i</code><sub>2</sub>, ..., <code>start</code>, and <code>stop</code> can be negative integers. E.g., if <code>i = -1</code>, it
refers to the last row/column; if <code>i = -2</code>, it denotes the row/column right before the last row/column; ... <code><a href=#submatrix>submatrix</a></code> and <code><a href=#subtable>subtable</a></code> allow this usage, too.<p></p></li>
<li>The default value of <code>step</code> depends on the values of <code>start</code> and <code>stop</code>. If <code>start &le; stop</code>, it is <code>1</code>; otherwise, it is <code>-1</code>.
And the default value of <code>stop</code> is <code>-1</code>, i.e., the index of the last entry of a row/column.<p></p></li>
<li><code>cc(A)</code> and <code>rr(A)</code> each flatten a matrix <em>rowwisely</em>, but <code>tt(A)</code> does it <em>columnwisely</em>.</li>
</ol>
<pre><code>-- use cc or rr to control matrix operations or let mathly determine the type of an operation

mathly = require('mathly')
a = mathly({1, 2, 3}, 3)
disp(a)
-- 1
-- 2
-- 3
a * {2, 3, 4}   -- or a * rr{2, 3, 4}, (3x1 matrix) * (1x3 matrix) --> 3x3 matrix
-- 2  3  4
-- 4  6  8
-- 6  9  12
a * cc{2, 3, 4} -- (3x1 matrix) * (3x1 matrix) --> (3x1 matrix) .* (3x1 matrix) in MATLAB
cc{2, 3, 4} * a --
-- 2
-- 6
-- 12
{2, 3, 4} * a   -- or rr{2, 3, 4} * a, (1x3 matrix) * (3x1 matrix) --> 1x1 matrix
-- 20

a = mathly({1, 2, 3})
disp(a)
-- 1  2  3
a * {2, 3, 4}   -- or a * cc{2, 3, 4}, (1x3 matrix) * (3x1 matrix) --> 1x1 matrix
-- 20
a * rr{2, 3, 4} -- (1x3 matrix) * (1x3 matrix) --> (1x3 matrix) .* (1x3 matrix) in MATLAB
-- 2  6  12

-- another basic usage of cc and rr, taking rr as the example

A = mathly{{1, 2, 3, 4}, {2, 3, 4, 5}, {3, 4, 5, 6}}
disp(A)
-- 1  2  3  4
-- 2  3  4  5
-- 3  4  5  6
rr({1, 2, 3})   -- or rr(cc(A, 1)) -- return a row vector
-- 1  2  3
rr(A)           -- return a row vector with elements of a matrix flattened rowwisely
--  1  2  3  4  2  3  4  5  3  4  5  6
rr(A, 2)        -- return the 2nd row of A
-- 2  3  4  5
rr(A, -1)       -- return the last row of A
-- 3  4  5  6
rr(A, {1, -2, 1, -1}) -- rows can be rearranged in certain order with repetitions allowed
-- 1  2  3  4
-- 2  3  4  5
-- 1  2  3  4
-- 3  4  5  6

-- complicated usage that is not needed usually

rr(A, 3, 2)     -- return the 3rd row of A starting from the 2nd column to the last
-- 4  5  6
rr(A, 3, 2, 3)  -- return the 3rd row of A starting from the 2nd column to the 3rd one
-- 4  5
rr(A, {1, -2, 1, -1}, 2, -1) -- or rr(A, {1, -2, 1, -1}, 2) -- from the 2nd column to the last
-- 2  3  4
-- 3  4  5
-- 2  3  4
-- 4  5  6
rr(A, {1, -2, 1, -1}, 2, -1, 2)
-- 2  4
-- 3  5
-- 2  4
-- 4  6
rr(A, {1, -2, 1, -1}, -1, 2, -2) -- from the last to the second
-- 4  2
-- 5  3
-- 4  2
-- 6  4
</code></pre>
<p>&#x2713; &nbsp; <code>tt(x, i1, i2, s)</code> may be used to replace <a href=#subtable><code>subtable</code></a>. If <code>x</code> is a mathly matrix, it is converted to a table columnwisely first;
if it is any other table, it is flattened first. Comparatively, <code>subtable</code> doesn't carry out any conversion.
For row wise flattening, see also <a href=#cc><code>cc</code></a>, <a href=#rr><code>rr</code></a>, and <a href=#flatten><code>flatten</code></a>.</p>
<table><tbody>
<tr><td width=20></td><td><code>i1</code></td><td> </td><td width=10> </td><td>Initial value of index (default: 1).</td></tr>
<tr><td></td><td><code>i2</code></td><td> </td><td> </td><td>Terminal value of index (default: size of the converted table of <code>x</code>).</td></tr>
<tr><td></td><td><code>s</code></td><td> </td><td> </td><td>Step size (default: <code>1</code> or <code>-1</code>, depending on the values of <code>i1</code> an <code>i2</code>).</td></tr>
</tbody></table>
<pre><code>
mathly = require('mathly')
a = mathly{{52, 67, 82}, {82, 15, 70}, {94, 82, 50}}
-- 52  67  82
-- 82  15  70
-- 94  82  50
display(tt(a)) -- flatten a matrix columnwisely first
-- {52, 82, 94, 67, 15, 82, 82, 70, 50}
display(tt(a, 3, -1)) -- or display(tt(a, 3))
-- {94, 67, 15, 82, 82, 70, 50}
display(tt(a, -6, -2))
-- {67, 15, 82, 82, 70}}
display(tt(a, 1, -1, 3))
-- {52, 67, 82}
display(tt({1, 2, 3, 4, 5, 6}, -1, 1, -1))
-- {6, 5, 4, 3, 2, 1}
display(tt({1, 2, 3, 4, 5, 6}, -1, 1, -2))
-- {6, 4, 2}

x = {1, 2, {3}, 4, {{5, 6, {7}}}}
display(tt(x))
-- {1, 2, 3, 4, 5, 6, 7}
display(subtable(x, 2, 4)) -- no flattening
-- {2, {3}, 4}
display(tt(x, 2, 4))       -- flattened first
-- {2, 3, 4}
display(tt(x, 2))
-- {2, 3, 4, 5, 6, 7}
</code></pre>

<h4>&bull; &nbsp; <a name=select href=#m><code>select(tbl, f)</code></a></h4>
<p>Return elements of table <code>tbl</code> that satisfy specified conditions. (<code>f</code> defaults to <code>tbl</code>.)</p>
<p>If <code>f</code> is a boolean function, return 1) a table of elements of <code>tbl</code> (row wise) that satisfy <code>f(x)</code>
and 2) a table of elements of <code>tbl</code> with those elements replaced by 0 when they fail to satisfy <code>f(x)</code>.</p>
<p>If <code>f</code> is a table/matrix, return 1) a table of elements of <code>tbl</code> (row wise) that correspond to nonzero
elements of <code>f</code> and 2) <code>tbl</code> with entries replaced with corresponding zero elements of <code>f</code>.</p>
<pre><code>mathly = require('mathly')
A = mathly{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
disp(A)
-- 1  2  3
-- 4  5  6
-- 7  8  9
x, C = select(A, function(x) return x > 4 and x % 2 == 0 end)
disp(x)
-- {6, 8}
disp(C)
-- 0  0  0
-- 0  0  6
-- 0  8  0
B = select(A, C)
disp(B)
-- {6, 8}
A =  mathly{{2, 3, 4}, {5, 6, 7}, {8, 9, 10}}
disp(A)
-- 2  3  4
-- 5  6  7
-- 8  9 10
x, D = select(A, C)
disp(x)
-- {7, 9}
disp(D)
-- 0  0  0
-- 0  0  7
-- 0  9  0

A = mathly{{1, 0, 3}, {0, 5, 0}, {7, 8, 0}}
disp(A)
-- 1  0  3
-- 0  5  0
-- 7  8  0
disp(select(A))
-- {1, 3, 5, 7, 8}

x = {0, 1, 2, 0, 0, 3, 0, 4, 0, 0}
disp(select(x))
-- {1, 2, 3, 4}

x = {1, 2, {3, 4, 5, {6, 7, 8, {9, 10}}, 11, 12}, 13, 14}
y, A = select(x, function(x) return x % 2 == 0 end)
disp(y)
-- {2, 4, 6, 8, 10, 12, 14}
disp(A)
-- {0, 2, {0, 4, 0, {6, 0, 8, {0, 10}}, 0, 12}, 0, 14}
</code></pre>

<h4>&bull; &nbsp; <a name=copy href=#m><code>copy(x)</code></a></h4>
<P>Make a deep copy of <code>x</code>.</P>
<pre><code>mathly= require('mathly')
a = {1, 2, {3, 4, {5, 6}}}
b = copy(a)
b[3] = 0
display(a)
-- {1, 2, {3, 4, {5, 6}}}
display(b)
-- {1, 2, 0}

A = mathly{{1, 2}, {3, 4}}
B = copy(A)
inv(A) -- A is modified
disp(A)
-- 1  0.0000
-- 0       1
disp(B)
-- 1 2
-- 3 4

x = {1, 2, hi = {2, 3, abc = {1, 2, bcd = 6, 2, 7, 'hello', true, false, cde = 1}}}
display(x)
-- {1, 2, hi = {2, 3, abc = {1, 2, 2, 7, 'hello', true, false, cde = 1, bcd = 6}}}
y = copy(x)
x.hi.abc.bcd = nil
display(x)
-- {1, 2, hi = {2, 3, abc = {1, 2, 2, 7, 'hello', true, false, cde = 1}}}
display(y)
-- {1, 2, hi = {2, 3, abc = {1, 2, 2, 7, 'hello', true, false, cde = 1, bcd = 6}}}
</code></pre>

<h4>&bull; &nbsp; <a name=cross href=#m><code>cross(a, b)</code></a></h4>
<P>Return the cross/vector product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>}</code>
and <code>b = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>}</code>.</P>
<pre><code>require 'mathly'
display(cross({1, 2, 3}, {3, 4, 5}))
-- {-2, 4, -2}
</code></pre>

<h4>&bull; &nbsp; <a name=demathly href=#m><code>demathly(x)</code></a></h4>
<p>Force <code>x</code> to be an ordinary Lua table. It is not a mathly matrix now.</p>
<p>It is provided for special purposes. If no matrix operations are needed/allowed or the structure of a
matrix is damaged (on purpose), you had better call it.</p>
<p>See also: <a href=#mathly>mathly</a>.</p>
<pre><code>require('mathly')
A = mathly{{1, 2}, {3, 4}}
A[1][2] = {5, 6, 7}
A[3] = 10
demathly(A) -- A is no longer an ordinary matrix
det(A) -- now allowed
disp(A)
disp(map(function(x) return 2*x + 1 end, A)) -- map is still a great tool
</code></pre>

<h4>&bull; &nbsp; <a name=diag href=#m><code>diag(A, ...)</code></a></h4>
<ol>
<li><code>diag( A, k )</code>, where <code>A</code> is a mathly <code>mxn</code> matrix, <code>m &ne; 1</code> and <code>n &ne; 1</code>.
<p>Return the table of all entries of the <code>k</code>-th diagonal as a column vector.</p>
<p>The second argument <code>k</code> is optional. Its default value is 0.</p>
<p>Which diagonal? If <code>k = 0</code>, the main diagonal; if <code>k = j</code>, the diagonal <code>j</code> rows above (if <code>j &gt; 0</code>)
or <code>-j</code> rows below the main diagonal (if <code>j &lt; 0</code>). E.g., if <code>k = 1</code>, the diagonal right above the main
diagonal; if <code>k = -1</code>, the diagonal right below the main diagonal.</p></li>

<li><code>diag(v)</code>, where <code>v</code> is a table or a row/column vector.
<p>Return a <code>nxn</code> matrix with <code>v</code> as its main diagonal, where <code>n = length(v)</code>.</p></li>

<li><code>diag(v, k)</code>, where <code>v</code> is a table or a row/column vector.
<p>If <code>k &gt; 0</code>, return a matrix with <code>v</code> as the diagonal <code>k</code> rows above the main diagonal.</p>
<p><code>If k &lt; 0</code>, return a matrix with <code>v</code> as the diagonal <code>-k</code> rows below the main diagonal</p>
<p>If <code>k = 0</code>, same as <code>diag(v)</code>.</p></li>

<li><code>diag(v, m, n)</code>, where <code>v</code> is a table or a row/column vector.</p>
<p>Return a <code>mxn</code> matrix with vector v (or first elements in it) as its main diagonal.</p></li>
</ol>
<p>See also: <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}
disp(a)
-- 1  2  3
-- 2  3  4
-- 3  4  5
-- 4  5  6
disp(diag(a))
-- 1
-- 3
-- 5
disp(diag(a, 1))
-- 2
-- 4
disp(diag(a, -2))
-- 3
-- 5
diag({1, 2, 3})
-- 1  0  0
-- 0  2  0
-- 0  0  3
diag(cc{1, 2, 3, 4}, 3, 2)
-- 1  0
-- 0  2
-- 0  0
diag({1, 2, 3},2)
-- 0  0  1  0  0
-- 0  0  0  2  0
-- 0  0  0  0  3
-- 0  0  0  0  0
-- 0  0  0  0  0
diag({1, 2, 3},-1)
-- 0  0  0  0
-- 1  0  0  0
-- 0  2  0  0
-- 0  0  3  0
diag({2,3,4,5}, 1) + diag({1,2,3,4,5}) + diag({3,4,5,6}, -1) -- See also: <a name=diag1></a><a href=#remake1>remake</a>
-- 1  2  0  0  0
-- 3  2  3  0  0
-- 0  4  3  4  0
-- 0  0  5  4  5
-- 0  0  0  6  5
</code></pre>

<h4>&bull; &nbsp; <a name=disp></a><a name=display href=#m><code>disp(A), display(x)</code></a></h4>
<table>
<tr><td><code>disp(x)</code></td><td> - </td><td>Print a mathly matrix. If <code>x</code> is not a mathly matrix, <code>display</code> is called to print it.</td></tr>
<tr><td><code>display(x)</code></td><td> - </td><td>Print a table, including any mathly matrix, with structure.</td></tr>
</table>
<p>&#x2713; &nbsp; You can always use <code>disp</code> in all cases (except that you want to know the structure of a mathly matrix).</p>
<pre><code>require 'mathly'
a = eye(3)
disp(a)
-- 1 0 0
-- 0 1 0
-- 0 0 1
display(a)
-- {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}

x = {1, 2, {3, 4, {5, 6, {7, 8, {9}}}}}
disp(x) -- or display(x)

x = {1, 2, hi = {2, 3, my = {1, 2, 3, you = 6, 5, 4, 2, 7, 'hello', true, false, 5, yes = 1}}}
disp(x) -- or display(x)
</code></pre>

<h4>&bull; &nbsp; <a name=dot href=#m><code>dot(a, b)</code></a></h4>
<P>Return the dot/inner product of <code>a = {a<sub>1</sub>, a<sub>2</sub>, ...}</code>
and <code>b = {b<sub>1</sub>, b<sub>2</sub>, ...}</code>.</P>
<pre><code>require 'mathly'
display(dot({1, 2, 3}, {3, 4, 5}))
-- 26
display(dot({1, 2}, {3, 4}))
-- 11
</code></pre>

<h4>&bull; &nbsp; <a name=eval href=#m><code>eval(str)</code></a></h4>
<p>Evaluate the expression in <code>str</code> and return the result.</p>
<p>It implements the functionality of <code>loadstring</code> of some earlier versions
of Lua and <code>eval</code> of Python and some other programming languages.</p>
<pre><code>require('mathly')
x = eval('    2 * 3 - 5   ')
print(x)
-- 1

x = eval('3.14   ')
print(x * 2)
-- 6.28

x = eval('    2*pi   ')
print(x)
-- 6.2831853071796

x = eval('cos{0, pi/6, pi/4, pi/3, pi/2, pi}')
disp(x)
-- {1.0000, 0.8660, 0.7071, 0.5000, 0.0000, -1.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=expand href=#m><code>expand(A, m, n, v)</code></a></h4>
<p>Return an expanded/shrunk mathly matrix with value <code>v</code>'s added or entries dropped.</p>
<p>The default value of <code>v</code> is 0, and the default value of <code>n</code> is <code>m</code>.</p>
<p>See also: <a href=#diag><code>diag</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
a = mathly{{52, 67, 82}, {82, 15, 70}, {94, 82, 50}}
disp(a)
-- 52  67  82
-- 82  15  70
-- 94  82  50
disp(expand(a, 2, 4))
-- 52  67  82  0
-- 82  15  70  0
disp(expand(a, 4, 5, -1))
-- 52  67  82  -1 -1
-- 82  15  70  -1 -1
-- 94  82  50  -1 -1
-- -1  -1  -1  -1 -1
disp(expand(a, 2))
-- 52  67
-- 82  15
</code></pre>

<h4>&bull; &nbsp; <a name=flatten href=#m><code>flatten(x)</code></a></h4>
<p>Remove the structure of table <code>x</code> and return a table of all atomic elements in <code>x</code> in order.</p>
<p>If <code>x</code> is a mathly matrix, it does rowwisely. For columnwise flattening, see <a href=#tt><code>tt(...)</code></a>.</p>
<pre><code>mathly = require('mathly')
x = {1, 2, {3, 4, {5, 6, {7, 8, {9}}}}}
y = flatten(x)
display(y)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9}

A = mathly{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
-- 1 2 3
-- 4 5 6
-- 7 8 9
a = flatten(A)
display(a)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9} -- row wise
b = flatten(A^T) -- or b = tt(A^T)
display(b)
-- {1, 4, 7, 2, 5, 8, 3, 6, 9} -- column wise
</code></pre>

<h4>&bull; &nbsp; <a name=fliplr></a><a name=flipud href=#m><code>flipud(A), fliplr(A)</code></a></h4>
<table>
<tr><td><code>flipud(A)</code></td><td> - </td><td>Return a matrix with rows of matrix <code>A</code> reversed. (ud: upside down)</td></tr>
<tr><td><code>fliplr(A)</code></td><td> - </td><td>Return a matrix with columns of matrix <code>A</code> reversed. (lr: from left to right)</td></tr>
</table>
<p>See also: <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}
disp(a)
-- 1  2  3
-- 2  3  4
disp(flipud(a))
-- 2  3  4
-- 1  2  3
disp(fliplr(a))
-- 3  2  1
-- 4  3  2
</code></pre>

<h4>&bull; &nbsp; <a name=format href=#m><code>format(fmt)</code></a></h4>
<p>Reset or specify the format of the output of <code>disp(...)</code>. <code>fmt</code> can be any of the following options.</p>
<table><tbody>
<tr><td width=20></td><td><code>'bank'</code></td><td> </td><td width=10> </td><td>2 decimal places</td></tr>
<tr><td width=20></td><td><code>'short'</code></td><td> </td><td width=10> </td><td>4 decimal places (default).</td></tr>
<tr><td width=20></td><td><code>'long'</code></td><td> </td><td width=10> </td><td>15 decimal places</td></tr>
</tbody></table>

<h4>&bull; &nbsp; <a name=hasindex href=#m><code>hasindex(tbl, idx)</code></a></h4>
<p>Check if table <code>tbl</code> contains index <code>idx</code>.</p>
<pre><code>require 'mathly'
opt = {layout={width=900, height=400, grid={rows=2, columns=2}, title='Example'}}
print(hasindex(opt, 'grid'))
-- true
print(hasindex(opt, 'rows'))
-- true
print(hasindex(opt, 'color'))
-- false
</code></pre>

<h4>&bull; &nbsp; <a name=horzcat href=#m><code>horzcat(A, B, ...)</code></a></h4>
<P>Concatenate matrices A, B, ... in order horizontally. Matrices must have the same number of rows.</P>
<p><em>Operator <code>..</code> can be used to replace <code>horzcat</code>.</em></p>
<p>See also: <a href=#vertcat><code>vertcat</code></a>; <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
A = mathly{{1, 2}, {3, 4}}
disp(A)
-- 1  2
-- 3  4
B = mathly{{5}, {6}}
disp(B)
-- 5
-- 6
C = mathly{{7, 8, 9}, {10, 11, 12}}
disp(C)
--  7  8  9
-- 10 11 12
D = A .. B .. C -- same as horzcat(A, B, C)
disp(D)
-- 1  2  5  7  8  9
-- 3  4  6 10 11 12
disp(rr{1, 2, 3} .. rr{4, 5})
--  1  2  3  4  5

b = {5, 6}
disp(A .. cc(b)) -- augmented coefficient matrix for Ax = b
-- 1  2  5
-- 3  4  6
</code></pre>

<h4>&bull; &nbsp; <a href=#m name=input><code>input(prompt, s)</code></a></h4>
<p>Take user's input from keyboard and return a string if <code>s = 's'</code>; otherwise, evaluate the input expression and return the result.</p>
<p><code>prompt</code> is the text displayed to user. <code>s</code> defaults to <code>nil</code>.</p>
<pre><code>require('mathly')
x = input('Please enter a number: ')
print(x * 10)

x = input('Do you want to continue (Y/N)? ', 's')
s = string.match(x, "^%s*(%w+)")
if s == nil then
  print("No valid input was entered.")
else
  printf("You entered %s.", string.upper(s))
end

x = input('Expression to evaluate: ') -- you may enter sin(pi/2), {1, {2, {3}}}, 1 + 2 * 3, etc.
print(x)
</code></pre>

<h4>&bull; &nbsp; <a name=inv href=#m><code>inv(A)</code></a></h4>
<p>Return the inverse of square mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> is modified.</p>
<pre><code>mathly = require('mathly')
I = eye(3)
A = mathly{{1, 2, 3}, {3, 4, 5}, {-1, 2, 0}}
B = copy(A)
C = inv(A) * B
disp(C)
</code></pre>

<h4>&bull; &nbsp; <a name=ismember href=#m><code>ismember(x, table)</code></a></h4>
<p>Check if <code>x</code> is a member of <code>table</code>.</p>
<pre><code>require 'mathly'
x = {1, 2, 3, {4, 5, {6}}}
print(ismember(3, x))
-- true
print(ismember(4, x))
-- false
</code></pre>

<h4>&bull; &nbsp; <a name=lagrangepoly href=#m><code>lagrangepoly({x1, x2, ...}, {y1, y2, ...}, xx), lagrangepoly({{x1, y1}, {x2, y2}, ...}, xx)</code></a></h4>
<p>Return the Lagrange interpolating polynomial, defined by data <code>x = {x1, x2, ...}</code> and <code>y = {y1, y2, ...}</code>, or the value(s) of the polynomial at <code>xx</code>.</p>
<p>If <code>xx</code> is provided, return the value(s) of the polynomial at <code>xx</code>;
otherwise, return the string of the polynomial.</p>
<p>See also: <a href=#polynomial><code>polynomial</code></a>, <a href=#polyval><code>polyval</code></a>.</p>
<pre><code>require 'mathly'
disp(lagrangepoly({1, 2}, {3, 4}))
-- function f(x) return -3.0*(x - 2) + 4.0*(x - 1) end
disp(lagrangepoly({1, 2}, {3, 4}, 5))
-- 7.0000
disp(lagrangepoly({1, 2}, {3, 4}, {5, -6, 100}))
-- {7.0000, -4.0000, 102.0000}

s = lagrangepoly({1, 2, 3}, {3, 4, 5})
disp(s)
-- function f(x) return 1.5*(x - 2)*(x - 3) - 4.0*(x - 1)*(x - 3) + 2.5*(x - 1)*(x - 2) end
load(s)() -- activate the function
f(10)
-- 12.0
disp(lagrangepoly({1, 2, 3}, {3, 4, 5}, {10, 1, -5}))
-- {12.0000, 3.0000, -3.0000}

disp(lagrangepoly({{1, 3}, {2, 0}, {0, 4}}))
-- function f(x) return -3.0*(x - 2)*x + 2.0*(x - 1)*(x - 2) end
disp(lagrangepoly({{1, 3}, {2, 0}, {0, 4}}, {10, 1, -5}))
-- {-96.0000, 3.0000, -21.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=linsolve href=#m><code>linsolve(A, b, opt)</code></a></h4>
<p>Solve a linear system <code>Ax = b</code> and return the solution.</p>
<p>The argument <code>opt</code> is optional:</p>
<ol>
<li><code>'LT'</code>: <code>A</code> is lower triangular</li>
<li><code>'UT'</code>: <code>A</code> is upper triangular</li>
</ol>
<p>If <code>A</code> is neither upper nor lower triangular, <a href=#rref><code>rref(A, b)</code></a> is called, and <code>b</code> finally holds the solution.</p>
<pre><code>require 'mathly'
a = randi(100, 3)
aa = copy(a)
b = randi(100, 3, 1)
disp(a)
--  58  18  88 -- it varies
--  68  30  71
--  14  75  49
disp(b)
-- 89
-- 6
-- 4

x = linsolve(a, b)
disp(x)
-- -2.1499
-- -1.3064
--  2.6955

x = linsolve(aa, {89, 6, 4}) -- or linsolve(aa, {{89}, {6}, {4}})
disp(x)
-- -2.1499
-- -1.3064
--  2.6955
</code></pre>

<h4>&bull; &nbsp; <a name=linspace href=#m><code>linspace(x, y, n)</code></a></h4>
<p>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code> and ending at <code>y</code>.</p>
<p>See also: <a href=#range><code>range</code></a>, <a href=#seq><code>seq</code></a>.</p>
<pre><code>require 'mathly'
x = linspace(0, 2*pi, 500)
y = cos(x)
plot(x, y, '-or')
</code></pre>

<h4>&bull; &nbsp; <a name=lu href=#m><code>lu(A)</code></a></h4>
<p>Return <code>L</code> and <code>U</code> of LU factorization <code>A = LU</code>, where <code>L</code> and <code>U</code> are lower and upper triangular matrices, respectively.</p>
<pre><code>mathly = require('mathly')
A = mathly{{1, 2, 3}, {2, 3, 4}, {-1, 0, 2}}
L, U = lu(A)
disp(L)
--  1       0       0
--  2 -1.0000       0
-- -1  2.0000  1.0000
disp(U)
-- 1  2.0000  3.0000
-- 0       1  2.0000
-- 0       0       1
disp(L * U - A)
--      0  0.0000  0.0000
-- 0.0000  0.0000  0.0000
-- 0.0000  0.0000  0.0000
</code></pre>

<h4>&bull; &nbsp; <a name=map href=#m><code>map(f, tbl1, tbl2, ...)</code></a></h4>
<p>Apply function <code>f</code> to each group of corresponding atomic elements in tables, <code>tbl1, tbl2, ...</code>, and return the result.</p>
<p>&#x2713; &nbsp; <code>tbl1, tbl2, ...</code> must be tables of the same structure.
<pre><code>mathly = require('mathly')
a = range(1, 10) -- seq(1, 10) or seq(10)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
function f(x) return x * x end
b = map(f, a)
display(b)
-- {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}

display(map(function(x, y) return x + y end, a, b)) -- x and y are taken from a and b, respectively
-- {2, 6, 12, 20, 30, 42, 56, 72, 90, 110}

x = {1, 2, {3, 4, {5, 6, {7}}}}
display(map(f, x))
-- {1, 4, {9, 16, {25, 36, {49}}}}

A = mathly{{1, 2, 3}, {3, 4, 5}, {-1, 2, 0}}
map(f, A) -- A is a mathly matrix, the result of map(f, A) is a mathly matrix, too.
-- 1   4   9
-- 9  16  25
-- 1   4   0

A = {{1, 2, 3}, {2, 3, 4}}
B = {{3, 4, 5}, {5, 6, 7}}
C = map(function(x, y) return x * y end, A, B) -- MATHLAB: A .* B
disp(C)
-- {{3, 8, 15}, {10, 18, 28}}
disp(map(function(x, y, z) return x + y - z end, A, B, C)) -- x, y, and z are taken from A, B, and C, respectively
-- {{1, -2, -7}, {-3, -9, -17}}

x1 = {1, 2, 3, 4, A = 5, 6, {0, 1, 2, B = 3}}
disp(x1)
-- {1, 2, 3, 4, 6, {0, 1, 2, B = 3}, A = 5}
x2 = map(function(x) return x*x end, x1)
-- {1, 4, 9, 16, 36, {0, 1, 4, B = 9}, A = 25}
disp(map(function(x, y) return x + y end, x1, x2))
-- {2, 6, 12, 20, 42, {0, 2, 6, B = 12}, A = 30}
</code></pre>

<h4>&bull; &nbsp; <a name=mathly href=#m><code>mathly(...)</code></a></h4>
<p>It is the constructor of mathly matrices.</p>
<p>&#x2713; &nbsp; The command, <code>mathly = require('mathly')</code>, must be executed first.</p>
<table><tbody>
<tr><td width=18%><code>mathly(m, n, val)</code></td><td>Create a <code>mxn</code> mathly matrix of which each element assumes the value <code>val</code> (default: random numbers from 0 to 1).</td></tr>
<tr><td><code>mathly(A, m, n)</code></td><td>Create a <code>mxn</code> mathly matrix using elements of table/matrix <code>A</code> columnwisely; if <code>A</code> can't provide enough numbers, 0 is used; if <code>n</code> is not provided, it is so determined that least number of 0's are used.</td></tr>
</tbody></table>
<p>See also: <a href=#demathly><code>demathly</code></a>; <a href=#ones><code>ones, rand, randi, randn, zeros</code></a>; <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>; <a href=#repmat><code>repmat</code></a>.</p>
<pre><code>mathly = require('mathly')

A = mathly(3, 4)
disp(A)

disp(mathly(2, 5, -1))
-- -1  -1  -1  -1  -1
-- -1  -1  -1  -1  -1

mathly(1, 5, 0)
--  0  0  0  0  0

mathly({1, 2, 3, 4, 5, 6, 7}, 2)
-- 1  3  5  7
-- 2  4  6  0

mathly({1, 2, 3, 4, 5, 6, 7}, 2, 5)
-- 1  3  5  7  0
-- 2  4  6  0  0

a = mathly{{1, 2}, {3, 4}}
disp(a)
-- 1  2
-- 3  4

mathly(a, 3, 4)
-- 1  4  0  0
-- 3  0  0  0
-- 2  0  0  0
</code></pre>

<h4>&bull; &nbsp; <a name=max></a><a name=min href=#m><code>max(x)</code>, <code>min(x))</code></a></h4>
<p>If <code>x</code> is an array or row/column vector, return the largest/smallest of all elements in it; if it is a matrix, return a table consisting of the largest/smallest of each column of <code>x</code>.</p>
<table><tbody>
<pre><code>require 'mathly'

x = {1, -10, 2, 31, 4, 7}
print(min(x), max(x))
-- -10  31

a = randi({-50, 50}, 3, 5)
disp(a)
-- -12  -19   -15    6  -11
--   3   43    36   29  -26
-- -38   -9   -16   20   16
display(min(a))
-- {-38, -19, -16, 6, -26}
disp(max(a))
-- {3, 43, 36, 29, 16}
</code></pre>

<h4>&bull; &nbsp; <a name=mean href=#m><code>mean(x)</code></a></h4>
<ol>
<li>If <code>x</code> is a table or mathly row/column vector, return the mean of its elements;</li>
<li>If <code>x</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the mean value of
the <code>i</code>-th column of <code>x</code>.</p></li>
</ol>
<pre><code>mathly = require('mathly')
disp(mean({1,2,3}))
-- 2.0000
A = mathly{{1, 2, 3}, {2, 3, 4}, {3, 1, 2}}
disp(A)
-- 1  2  3
-- 2  3  4
-- 3  1  2
disp(mean(A))
-- 2.0000  2.0000  3.0000
print(mean('abc')) -- 'abc' --> {97, 98, 99}, string.byte('a') ...
-- 98.0
print(mean({'abc', 'de'})) --> strcat first: 'abcde' --> mean('abcde')
-- 99.0
</code></pre>

<h4>&bull; &nbsp; <a name=zeros></a><a name=rand></a><a name=randi></a><a name=randn></a><a name=ones href=#m><code>ones</code>, <code>zeros</code>, <code>rand</code>, <code>randi</code>, <code>randn</code></a></h4>
<p>The usage of these functions is the same except randi that can take more arguments.</p>
<table><tbody>
<tr><td width=20></td><td><code>ones(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 1.</td></tr>
<tr><td width=20></td><td><code>randi(x, m, n)</code></a></td><td> </td><td width=10> </td><td>Return a mathly matrix of which each element is a random integer in a specified range.</td></tr>
<tr><td width=20></td><td><code>zeros(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is 0.</td></tr>
<tr><td width=20></td><td><code>rand(m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is a random number in [0, 1].</td></tr>
<tr><td width=20></td><td><code>randn(m, n, &mu;, &sigma;)</code></a></td><td> </td><td width=10> </td><td>Return a mathly matrix of normally distributed numbers (&mu; and &sigma; default to 0 and 1, respectively).</td></tr>
<tr><td width=20></td><td> </td><td> </td><td width=10> </td><td> </td></tr>
<tr><td width=20></td><td> </td><td> </td><td width=10> </td><td><u>Note</u>: Each function returns a table rather than a mathly column vector if <code>m = 1</code>.</td></tr>
</tbody></table>
<pre><code>
require 'mathly'
A = ones(2) -- or ones(2, 2)
disp(A)
-- 1 1
-- 1 1
B = zeros(2, 3) + 5
disp(B)
-- 5 5 5
-- 5 5 5
disp(A * B)
-- 10 10 10
-- 10 10 10

C = zeros(1, 5)  -- return a table rather than a mathly matrix
-- C + 10 -- not allowed because C is not a mathly vector/matrix
display(C)
-- {0, 0, 0, 0, 0}

D = zeros(3, 1)  -- a mathly column vector
disp(D)
-- 0
-- 0
-- 0
display(D)
-- {{0}, {0}, {0}}
disp(2*D + 3)
-- 3
-- 3
-- 3

A = randi({0, 100}, 2, 3) -- each element is a random integer in [0, 100]
disp(A)
A = randi({50, 90}, 3, 1) -- each element is a random integer in [50, 90]
display(A)
A = randi({50, 90}, 1, 5) -- return a table rather than a mathly matrix
display(A)

disp(randn(3, 5))
disp(randn(3, 5, 70, 12.55))
</code></pre>
<table><tbody>
<p>&#x2713; &nbsp; The usage of <code>randi(...)</code> is different.</p>
<tr><td><code>randi(imax)</code></td><td> </td><td width=10> </td><td>Return a random integer in <code>[1, imax]</code>.</tr>
<tr><td><code>randi({imin, imax})</code></td><td> </td><td width=10> </td><td>Return a random integer in <code>[imin, imax]</code>.</tr>
<tr><td><code>randi(imax, m, n)</code></td><td> </td><td width=10> </td><td>Return a <code>mxn</code> mathly matrix of which each element is in <code>[1, imax]</code>. (<code>n</code> is optional. The default is <code>m</code>.)</tr>
<tr><td><code>randi({imin, imax}, m, n)</code></td><td> </td><td width=10> </td><td>Return a mxn mathly matrix of which each element is in <code>[imin, imax]</code>. (<code>n</code> is optional. The default is <code>m</code>.)</tr>
</tbody></table>

<h4>&bull; &nbsp; <a name=polynomial href=#m><code>polynomial({x1, x2, ...}, {y1, y2, ...}, xx), polynomial({{x1, y1}, {x2, y2}, ...}, xx)</code></a></h4>
<p>Construct a polynomial, defined by data <code>x = {x1, x2, ...}</code> and <code>y = {y1, y2, ...}</code>.</p>
<p>If <code>xx</code> is provided, return the value(s) of the polynomial at (each of) <code>xx</code>;
otherwise, return the string and the coefficients of the polynomial.</p>
<p>See also: <a href=#lagrangepoly><code>lagrangepoly</code></a>, <a href=#polyval><code>polyval</code></a>.</p>
<pre><code>require 'mathly'
disp(polynomial({1, 2}, {3, 4}))
-- function p(x) return 1.0*x + 2.0 end
disp(polynomial({1, 2}, {3, 4}, 5))
-- 7.0000
disp(polynomial({1, 2}, {3, 4}, {5, -6, 100}))
-- {7.0000, -4.0000, 102.0000}

s, coefs = polynomial({1, 2, 3}, {3, 1, 4})
disp(s)
-- function p(x) return 2.5*x^2 - 9.5*x + 10.0 end
load(s)() -- activate the function
p(10)
-- 165.0
polyval(coefs, 10)
-- 165.0

disp(polynomial({1, 2, 3}, {3, 1, 4}, {10, 1, -5}))
-- {165.0000, 3.0000, 120.0000}

s, coefs = polynomial({{1, 3}, {2, 1}, {3, 4}})
disp(s)
disp(polyval(coefs, {10, 1, -5}))
-- {165.0000, 3.0000, 120.0000}
-- function p(x) return 2.5*x^2 - 9.5*x + 10.0 end
disp(polynomial({{1, 3}, {2, 1}, {3, 4}}, {10, 1, -5}))
-- {165.0000, 3.0000, 120.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=polyval href=#m><code>polyval(coefs, x)</code></a></h4>
<p>Evaluate at <code>x</code> the value of a polynomial of which the coefficients are specified
in a table <code>coefs</code>.</p>
<p>For a polynomial of <code>p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + ... +
a<sub>1</sub>x + a<sub>0</sub></code>,
<code>coefs = {a<sub>n</sub>, a<sub>n-1</sub>, ..., a<sub>0</sub>}</code>.
For example, <code>p(x) = -2x<sup>4</sup> + 4x<sup>2</sup> - 5x</code>, <code>coef = {-2, 0, 4, -5, 0}.</code></p>
<p>See also: <a href=#lagrangepoly><code>lagrangepoly</code></a>, <a href=#polynomial><code>polynomial</code></a>.</p>
<pre><code>require 'mathly'
disp(polyval({1, 2, 1}, 0)) -- evaluate x<sup>2</sup> + 2x + 1 at x = 0
-- 1.0000
disp(polyval({1, 2, 1}, {0, 5, 9, 100})) -- evaluate at x = 0, 5, 9, 100
-- {1.0000, 36.0000, 100.0000, 10201.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=sprintf></a><a name=printf href=#m><code>printf(...)</code>, <code>sprintf(...)</code></a></h4>
<p>This kind of functions is a commonly used tool for printing or preparing a formatted string in many programming languages like C/C++ and MATLAB. They print or prepare a formatted string.</p>
<p>These two functions depend on <a href="manual.html#pdf-string.format"><code>string.format</code></a>.</p>
<table><tbody>
<tr><td width=20></td><td><code>printf</code></td><td> </td><td width=10> </td><td>Print a formatted string.</td></tr>
<tr><td width=20></td><td><code>sprintf</code></td><td> </td><td width=10> </td><td>Prepare a formatted string.</td></tr>
</tbody></table>

<h4>&bull; &nbsp; <a name=sum></a><a name=prod href=#m><code>prod(A)</code>, <code>sum(A)</code></a></h4>
<ol>
<li>If <code>A</code> is a table or mathly row/column vector, return the product/sum of its elements;</li>
<li>If <code>A</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the product/sum of
the <code>i</code>-th column of <code>A</code>.</p></li>
</ol>
<pre><code>mathly = require('mathly')
a = {1, 2, 3}
print(sum(a))
-- 6

a = {{1}, {2}, {3}}
print(sum(a))
-- 6

a = mathly{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}
disp(a)
--  1  2  3
--  2  3  4
--  3  4  5
disp(sum(a))
-- {6, 9, 12}
disp(prod(a))
-- {6, 24, 60}
</code></pre>

<h4>&bull; &nbsp; <a name=qr href=#m><code>qr(A)</code></a></h4>
<p>Return <code>Q</code> and <code>R</code> of QR factorization <code>A = QR</code>, where <code>A</code> is a <code>mxn</code> matrix, <code>Q</code> is a <code>mxn</code> matrix with orthonormal
column vectors, and <code>R</code> is an invertible upper triangular <code>nxn</code> matrix.</p>
<p>&#x2713; &nbsp; mathly applies the Gram-Schmidt process and requires that <code>m &ge; n</code>.
<pre><code>mathly = require('mathly')
A = mathly{{1, 2, 3}, {2, 3, 4}, {-1, 0, 2}}
Q, R = qr(A)
disp(Q)
--  0.4082  0.4364  -0.8018
--  0.8165  0.2182   0.5345
-- -0.4082  0.8729   0.2673
disp(R)
-- 2.4495  3.2660  3.6742
--      0  1.5275  3.9280
--      0       0  0.2673
disp(Q * R - A)
--  0.0000   0.0000   0.0000
--  0.0000   0.0000  -0.0000
-- -0.0000  -0.0000  -0.0000
</code></pre>

<h4>&bull; &nbsp; <a name=range href=#m><code>range(x, y, s)</code></a></h4>
<p>Return a table of numbers starting at <code>x</code>, in between <code>x</code> and <code>y</code>, and incrementing by <code>s</code> (1 by default).</p>
<p>See also: <a href=#linspace><code>linspace</code></a>, <a href=#seq><code>seq</code></a>.</p>
<pre><code>require 'mathly'
x = range(1, 10)
disp(x)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

display(range(10, 1, -1))
-- {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}

disp(range(0, 6, 0.5))
-- {0, 0.5000, 1.0000, 1.5000, 2.0000, 2.5000, 3.0000, 3.5000, 4.0000, 4.5000, 5.0000, 5.5000, 6.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=remake href=#m><code>remake(A, opt)</code></a></h4>
<p>Generate a lower (opt = 'LT'), upper (opt = 'UT'), diagonal (opt = 'DIAG'), or symmetrical (opt = 'SYM') matrix from matrix <code>A</code>.</p>
<p>If, say, <code>opt = {k<sub>1</sub>, k<sub>2</sub>, ..., k<sub>m</sub>}</code>, generate from matrix <code>A</code> a matrix which keeps the diagonal entries <code>k<sub>i</sub></code> rows above (<code>k<sub>i</sub> > 0</code>) or <code>-k<sub>i</sub></code> rows below (<code>k<sub>i</sub> < 0</code>) the main diagonal, <code>i = 1, 2, ..., m</code>.</p>
<p>See also: <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
A = reshape(seq(1, 25), 5, 5)
disp(A)
-- 1   6  11  16  21
-- 2   7  12  17  22
-- 3   8  13  18  23
-- 4   9  14  19  24
-- 5  10  15  20  25
remake(A, 'UT')
-- 1   6  11  16  21
-- 0   7  12  17  22
-- 0   0  13  18  23
-- 0   0  0   19  24
-- 0   0  0   0   25
remake(A, 'SYM')
-- 1   6  11  16  21
-- 6   7  12  17  22
-- 11  12 13  18  23
-- 16  17 18  19  24
-- 21  22 23  24  25
remake(A, {-1, 0, 1}) -- or remake(A, seq(-1,1)) -- See also: <a name=remake1></a><a href=#diag1>diag</a>
-- 1  6   0   0   0
-- 2  7  12   0   0
-- 0  8  13  18   0
-- 0  0  14  19  24
-- 0  0   0  20  25
remake(A, {-1, seq(1,3)})
-- 0  6  11  16   0
-- 2  0  12  17  22
-- 0  8   0  18  23
-- 0  0  14   0  24
-- 0  0   0  20   0
remake(randi({-100, 100}, 6), 'LT') -- generate randomly a lower triangular matrix
</code></pre>

<h4>&bull; &nbsp; <a name=repmat href=#m><code>repmat(A, m, n)</code></a></h4>
<p>Return a <code>mxn</code> block matrix with each entry a copy of matrix <code>A</code>. The default value of <code>n</code> is <code>m</code>.</p>
<p>See also: <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}}
disp(a)
-- 1  2  3
-- 2  3  4
disp(repmat(a, 2))
-- 1  2  3  1  2  3
-- 2  3  4  2  3  4
-- 1  2  3  1  2  3
-- 2  3  4  2  3  4
disp(repmat(a, 2, 3))
-- 1  2  3  1  2  3  1  2  3
-- 2  3  4  2  3  4  2  3  4
-- 1  2  3  1  2  3  1  2  3
-- 2  3  4  2  3  4  2  3  4
disp(repmat(5, 2, 3)) -- same as mathly(2, 3, 5)
-- 5  5  5
-- 5  5  5
</code></pre>

<h4>&bull; &nbsp; <a name=reshape href=#m><code>reshape(A, m, n)</code></a></h4>
<p>Rearrange columnwisely existing elements in a table or mathly matrix <code>A</code> and return a new <code>mxn</code> mathly matrix.</p>
<p>See also: <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
reshape({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3) -- return a 3x4 mathly matrix, where 4 is automatically determined
-- 1  4  7  10
-- 2  5  8  0
-- 3  6  9  0

reshape({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3, 5) -- no sufficient numbers in a table? fill with 0
-- 1  4  7  10  0
-- 2  5  8  0   0
-- 3  6  9  0   0

a = mathly{{1, 2, 3}, {-1, -2, -3}, {6, 7, 8}}
disp(a)
--  1  2  3
-- -1 -2 -3
--  6  7  8
b = reshape(a, 2)
disp(b)
--  1  6 -2  3  8
-- -1  2  7 -3  0
c = reshape(a, 2, 7)
disp(c)
--  1  6 -2  3  8  0  0
-- -1  2  7 -3  0  0  0
</code></pre>

<h4>&bull; &nbsp; <a name=reverse href=#m><code>reverse(tbl)</code></a></h4>
<p>Return a table with order of elements in table <code>tbl</code> reversed.</p>
<p>&#x2713; &nbsp; If <code>tbl</code> is a matrix, it is flattened columnwisely first to a table and then reversed.</p>
<pre><code>require('mathly')
a = seq(10)
disp(a)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
disp(reverse(a)) -- same as tt(a, #a, 1, -1) or tt(a, #a, 1)
-- {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
</code></pre>

<h4>&bull; &nbsp; <a name=rref href=#m><code>rref(A, ...)</code></a></h4>
<p>If there is one more argument, i.e., <code>rref(A, B)</code>, <code>A</code> and <code>B</code> will be merged horizontally into A.
<p><code>A</code> and <code>B</code> must be mathly matrices with the same row number.</p>
<p>Return the reduced row-echelon form of a mathly matrix <code>A</code>. <u>Note</u>: <code>A</code> and <code>B</code> are modified.</p>
<p>To solve <code>Ax = b</code>, call <code>rref(A, b)</code>, and <code>b</code> holds finally the solution.</p>
<pre><code>mathly = require('mathly')
a = mathly{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}
disp(a)
--  1  2  3
--  2  3  4
--  3  4  5
--  4  5  6
rref(a)
disp(a)
-- 1  0.0000 -1.0000
-- 0       1  2.0000
-- 0  0.0000  0.0000
-- 0  0.0000  0.0000

-- To solve Ax = b<sub>1</sub>, Ax = b<sub>2</sub>, and Ax = b<sub>3</sub>:
A = mathly{{1, 2, 3}, {2, 3, 4}, {0, -1, 2}}
b1 = mathly{{1},{2},{3}}
b2 = mathly{{1},{0},{5}}
b3 = mathly{{-2},{1},{2}}

B = mathly(horzcat(b1, b2, b3))
rref(A, B)
disp(B)
--  1.7500  -1.2500   7.2500
-- -1.5000  -1.5000  -3.5000
--  0.7500   1.7500  -0.7500
-- the solutions are
display((B^T)[1])
-- {1.75, -1.5, 0.75}
display((B^T)[2])
-- {-1.25, -1.50, 1.75}
display((B^T)[3])
-- {7.25, -3.5, -0.75}
</code></pre>

<h4>&bull; &nbsp; <a name=save href=#m><code>save(datafile, ...)</code></a></h4>
<p>Save specified or all user-defined variables and their values to Lua or MATLAB script file, <code>datafile</code>.</p>
<p>&#x2713; &nbsp; If the name of <code>datafile</code> ends in <code>.m</code>, the data is saved in the format of MATLAB
scripts. Note: Data like <code>x = {1, true, 'abc', c = {2, {3}, d = 'bcd'}}</code> are undefined in MATLAB.</p>
<p>&#x2713; &nbsp; <b>If no path is specified, the data file will be saved in the present working directory.</b></p>
<pre><code>mathly = require 'mathly'
a = randi(100, 3, 2)
disp(a)
--  48  43 -- it varies
--  71  72
--  66   5
b = {1, 2, {3, {4, {5, 6, {7}}}}}
c = 100
save('data_1.lua')            -- save all user-defined variables and their values to a file,
                              -- data_1.lua, in present working directory
                              -- to save to different place? e.g., 'D:/Workspace/data_1.lua'
save('data_2.lua', 'a', 'b')  -- save variables a, b, and their values to a file, data_2.lua,
                              -- in present working directory

save('data.m', {'a', 'b'})    -- save variables a, b, and their values to a file, data.m, in the format
                              -- of MATLAB scripts

clear()
print(a, b, c)
-- nil nil nil -- not defined

dofile('data_2.lua') -- load/recover the data
a = mathly(a)
disp(a)
--  48  43
--  71  72
--  66   5
disp(b)
-- {1, 2, {3, {4, {5, 6, {7}}}}}
print(c)
-- nil
</code></pre>

<h4>&bull; &nbsp; <a name=seq href=#m><code>seq(x, y, n)</code></a></h4>
<p>Return a table of <code>n</code> evenly spaced numbers starting at <code>x</code>, in <code>[x, y]</code>, ending at <code>y</code>.</p>
<p>See also: <a href=#linspace><code>linspace</code></a>, <a href=#range><code>range</code></a>.</p>
<pre><code>require 'mathly'
x = seq(1, 10) -- same as range(1, 10)
disp(x)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

x = seq(0, 1, 10) -- same as linspace(0, 1, 10)
display(x)
-- {0, 0.1111, 0.2222, 0.3333, 0.4444, 0.5556, 0.6667, 0.7778, 0.8889, 1.0000}
</code></pre>

<h4>&bull; &nbsp; <a name=sort href=#m><code>sort(tbl, compf)</code></a></h4>
<p>Sort table <code>tbl</code> and return the resulted table.</p>
<p>Provided for convenience, it is almost exactly the same as <a href="manual.html#pdf-table.sort"><code>table.sort(tbl, compf)</code></a>.</p>
<p>For <code>table.sort(tbl)</code>, <code>tbl</code> must be a variable rather than a specific table. Otherwise, say, <code>table.sort({2, 0, 2, 4})</code> actually does nothing.</p>
<p>&#x2713; &nbsp; <code>tbl</code> is changed if it is a variable.</p>
<pre><code>require('mathly')
a = seq(10)
disp(a)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
sort(a, function(x, y) return x > y end)
disp(a)
-- {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
disp(sort(a, function(x, y) return x < y end)) -- same as sort(a)
-- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
disp(sort({2, 0, 2, 4}))
-- {0, 2, 2, 4}
</code></pre>

<h4>&bull; &nbsp; <a name=plotsphericalsurface3d href=#m><code>plotsphericalsurface3d(ρ(θ,φ), θrange, φrange, title, resolution)</code></a></h4>
<p>Plot spherical function <code>ρ(θ, φ)</code>, where <code>θ</code> is in the range <code>θrange = {θ1, θ2}</code> (default: <code>{0, 2*pi}</code>)
and <code>φ</code> in the range <code>φrange = {φ1, φ2}</code> (default: <code>{0, pi}</code>). If <code>ρ(θ, φ)</code> is a number, the radius of a sphere centered at the origin, plot the sphere.</p>
<p><code>resolution</code>? See <a href=#resol><code>parametriccurve2d</code> and <code>polarcurve2d</code></a>.</p>
<pre><code>require('mathly')

plotsphericalsurface3d(1)
plotsphericalsurface3d(function(theta, phi) return theta + 2 * phi end, {0, 4*pi}, nil, 'Demo')
plotsphericalsurface3d(function(t, p) return 2 + sin(5*p + 7*t) end)  -- https://www.mathworks.com/help/symbolic/transform-spherical-coordinates-and-plot.html
</code></pre>

<h4>&bull; &nbsp; <a name=var></a><a name=std href=#m><code>std(x, opt)</code>, <code>var(x, opt)</code></a></h4>
<ol>
<li>If <code>x</code> is a table or mathly row/column vector, return the standard deviation of its elements;</li>
<li>If <code>x</code> is a <code>mxn</code> matrix, return a row vector of which the <code>i</code>-th element is the standard deviation of
the <code>i</code>-th column of <code>x</code>.</p></li>
</ol>
<p>If <code>opt = 0</code> (default), calculate for a population; otherwise, calculate for a sample.</p>
<pre><code>mathly = require('mathly')
disp(std({1,2,3}))
-- 1.0000
disp(std({1,2,3}, 1))
-- 0.8165
A = mathly{{1, 2, 3}, {2, 3, 4}, {4, 7, 9}}
disp(A)
-- 1  2  3
-- 2  3  4
-- 4  7  9
disp(std(A))
-- 1.5275  2.6458  3.2146
disp(var(A))
-- 2.3333  7  10.3333
disp(var(A, 1))
-- 1.5556  4.6667  6.8889
</code></pre>

<h4>&bull; &nbsp; <a name=strcat href=#m><code>strcat(...)</code></a></h4>
<p>Concatenate strings and return the resulted string.</p>
<p>See also: <a href=#tblcat><code>tblcat</code></a></p>
<pre><code>require('mathly')
print(strcat('Good', ' ', 'morning', '!'))
-- Good morning!
display(strcat({'1', '0', '0','1'}))
-- '1001'
print(strcat(34,'Hello, ', {'the ', 'world', '!'}, 34)) -- 34? ascii code for "
-- "Hello, the world!"
</code></pre>

<h4>&bull; &nbsp; <a name=subtable href=#m><code>subtable(tbl, i, j, s)</code></a></h4>
<p>Return a slice of table <code>tbl</code> starting from the <code>i</code>-th element to the <code>j</code>-th one with step size <code>s</code> (default: 1).</p>
<p>See also: <a href=#cc><code>cc, rr, tt</code></a></p>
<pre><code>mathly = require('mathly')
x = {1, 2, {3}, 4, {{5, 6, {7}}}}
display(subtable(x, 2, 4))
-- {2, {3}, 4}

a = mathly{1, 2, 3, 4, 5, 6, 7} -- {{1, 2, 3, 4, 5, 6, 7}}
display(subtable(a[1], 3, 5))
-- {3, 4, 5}

x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
y = subtable(x, 1, 11, 3)
display(y)
-- {1, 4, 7, 10}
display(subtable(x, 1, -1, 2)) -- -1? see <a href=#cc>notes</a>
-- {1, 3, 5, 7, 9, 11}
display(subtable(x, -1, 1, -1))
-- {12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
display(subtable(x, -1, 1, -2))
-- {12, 10, 8, 6, 4, 2}
</code></pre>

<h4>&bull; &nbsp; <a name=submatrix href=#m><code>submatrix(A, i, j, m, n, sr, sc)</code></a></h4>
<p>Return a mathly matrix, a block of mathly matrix <code>A</code>, starting at the <code>i</code>-th row
and <code>j</code>-th column and ending at the <code>m</code>-th row and <code>n</code>-th column
with row step <code>sr</code> and column step <code>sc</code>.</p>
<p>See also: <a href=#cc><code>cc, rr, tt</code></a>; <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#vertcat><code>vertcat</code></a>, <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')

a = mathly{{22, 15, 94, 77, 48}, {43, 58, 96, 64,  5},
           {20, 85, 90, 37, 92}, {16, 67,  9, 56, 33}}
disp(a)
-- 22  15  94  77  48
-- 43  58  96  64   5
-- 20  85  90  37  92
-- 16  67   9  56  33
b = submatrix(a, 3, 2, 4, 4) -- default value of sr and sc is 1 each
disp(b)
--  85  90  37
--  67   9  56
B = submatrix(a, 1, 1, 4, 4, 2, 1) -- or submatrix(a, 1, 1, 4, 4, 2)
disp(B)
-- 22  15  94  77
-- 20  85  90  37
C = submatrix(a, 2, 1, 4, 4, 2, 3) -- or submatrix(a, 1, 1, 4, 4, 2)
disp(C)
-- 43  64
-- 16  56
</code></pre>

<h4>&bull; &nbsp; <a name=tblcat href=#m><code>tblcat(t<sub>1</sub>, t<sub>2</sub>, ...)</code></code></a></h4>
<p>Flatten and concatenate tables <code>t<sub>1</sub></code>, <code>t<sub>2</sub></code>, ... and return the resulted table. The tables here may just be numbers, boolean values, or strings.</p>
<p>See also: <a href=#strcat><code>strcat</code></a></p>
<pre><code>mathly = require('mathly')
x = {1, 2}
y = {3, 4, {5}}
disp(tblcat(0, x, y, 10))
-- {0, 1, 2, 3, 4, {5}, 10}

z = mathly{{6}, {7}, {8}, {9}}
disp(tblcat(x, z, 11)) -- a column vector is automatically converted into a row vector
-- {1, 2, 6, 7, 8, 9, 11}

disp(tblcat(1, {c = 2, a = {3, 4}}, true, {ab = {5, 6, 'OK'}, aa = 7}))
-- {1, 2, 3, 4, true, 7, 5, 6, 'OK'}
</code></pre>

<h4>&bull; &nbsp; <a name=toc></a><a name=tic href=#m><code>tic()</code>, <code>toc(...)</code></a></h4>
<table><tbody>
<tr><td width=20></td><td><code>tic()</code></td><td> </td><td width=10> </td><td>Start a wall-clock timer.</td></tr>
<tr><td width=20></td><td><code>toc(...)</code></td><td> </td><td width=10> </td><td>Print or return elapsed time on a wall-clock timer.</td></tr>
</tbody></table>
<pre><code>
require 'mathly'

tic() -- start recording the time
for i = 1, 10000000 do
  x = math.cos(i) * math.sin(i)
end
toc()

x = toc(1) -- pass any non-nil value to toc to get the elapsed time; otherwise, print the elapsed time
printf("The loop took %.2f seconds.", x)
</code></pre>

<h4>&bull; &nbsp; <a name=unique href=#m><code>unique(tbl)</code></a></h4>
<p>Return the same data as in table <code>tbl</code> but with no repetitions. Data is sorted.</p>
<pre><code>require('mathly')
display(unique({4,5,2,1,-2,2,4,2,7,6,19}))
-- {-2, 1, 2, 4, 5, 6, 7, 19}
</code></pre>

<h4>&bull; &nbsp; <a name=vertcat href=#m><code>vertcat(A, B, ...)</code></a></h4>
<P>Concatenate matrices <code>A</code>, <code>B</code>, ... in order vertically. Matrices must have the same number of columns.</P>
<p>See also: <a href=#horzcat><code>..</code> (or <code>horzcat</code>)</a>; <a href=#diag><code>diag</code></a>, <a href=#expand><code>expand</code></a>, <a href=#flipud><code>flipud</code></a>, <a href=#fliplr><code>fliplr</code></a>, <a href=#remake><code>remake</code></a>, <a href=#reshape><code>reshape</code></a>, <a href=#repmat><code>repmat</code></a>, <a href=#submatrix><code>submatrix</code></a>; <code><a href=#select>select</a></code>.</p>
<pre><code>mathly = require('mathly')
A = mathly{{1, 2, 3}}
disp(A)
-- 1 2 3
B = mathly{{4, 5, 6}, {7, 8, 9}}
disp(B)
-- 4 5 6
-- 7 8 9
C = mathly{{10, 11, 12}}
disp(C)
-- 10 11 12
D = vertcat(A, B)
disp(D)
-- 1 2 3
-- 4 5 6
-- 7 8 9
E = vertcat(A, B, C)
disp(E)
-- 1   2  3
-- 4   5  6
-- 7   8  9
-- 10 11 12
</code></pre>

<h4>&bull; &nbsp; <a name=plot href=#m><code>plot(...)</code></a></h4>
<p>Plot the graph(s) of functions defined by data points, using specifications/options.</p>
<p><b>Some specifications:</b></p>
<ol>
<li>of a line, i.e., the graph of a function:<p><code>width</code> = 5</p><p><code>style</code> = <code>'-'</code> [solid, <code>':'</code> (dot), or <code>'--'</code> (dash)]</p>
<p><code>mode</code> = <code>'lines+markers'</code>, <code>'lines'</code>, or <code>'markers'</code></p></li><p></p>
<li>of a marker:<p><code>size</code> = 10</p><p><code>symbol</code> = <code>'circle'</code></p>
Some possible symbols are <code>circle</code>, <code>circle-open</code>, <code>circle-open-dot</code>, <code>cross</code>, <code>diamond</code>, <code>square</code>, <code>x</code>, <code>triangle-left</code>, <code>triangle-right</code>, <code>triangle-up</code>, <code>triangle-down</code>, <code>hexagram</code>, <code>star</code>, <code>hourglass</code>, <code>bowtie</code>.</li><p></p>
<li>of a plot:<p><code>layout</code> = {<code>width</code> = 500, <code>height</code> = 400, <code>grid</code> = {<code>rows</code> = 2, <code>columns</code> = 2}, <code>title</code> = 'Demo'}</p></li>
</ol>
<p><a name=plotspecs></a>Shortcuts for specifications like <code>'--ro'</code>:</p>
<table><tbody>
<thead><tr><td>shortcut</td><td> &nbsp; <td>symbol</td></tr></thead>
<tr><td><code>o</code></td><td> &nbsp; <td>circle</td></tr>
<tr><td><code>*</code></td><td> &nbsp; <td>star</td></tr>
<tr><td><code>x</code></td><td> &nbsp; <td>cross</td></tr>
<tr><td><code>^</code></td><td> &nbsp; <td>triangle-up</td></tr>
<tr><td><code>v</code></td><td> &nbsp; <td>triangle-down</td></tr>
<tr><td><code>></code></td><td> &nbsp; <td>triagle-right</td></tr>
<tr><td><code><</code></td><td> &nbsp; <td>triagle-left</td></tr>
</tbody></table>
<p></p>
<table><tbody>
<thead><tr><td>shortcut</td><td> &nbsp; <td>color</td></tr></thead>
<tr><td><code>r</code></td><td> &nbsp; <td>red</td></tr>
<tr><td><code>b</code></td><td> &nbsp; <td>blue</td></tr>
<tr><td><code>g</code></td><td> &nbsp; <td>green</td></tr>
<tr><td><code>c</code></td><td> &nbsp; <td>cyan</td></tr>
<tr><td><code>m</code></td><td> &nbsp; <td>magenta</td></tr>
<tr><td><code>y</code></td><td> &nbsp; <td>yellow</td></tr>
<tr><td><code>k</code></td><td> &nbsp; <td>black</td></tr>
<tr><td><code>w</code></td><td> &nbsp; <td>white</td></tr>
</tbody></table>
<p></p>
<p>As per filling regions, see <a href=#gobjspecs><code>arc, circle, line, parametriccurve2d, point, polygon, wedge</code></a>.</p>
<p></p>
<p><b>Some examples</b></p>
<pre><code>require 'mathly'
x = linspace(0, pi, 100)
y1 = sin(x)
y2 = map(math.cos, x)
y3 = map(function(x) return x^2*math.sin(x) end, x)

specs1 = {layout={width=700, height=900, grid={rows=4, columns=1}, title='Example'}}
specs2 = {color='blue', name='f2', layout={width=500, height=500, grid={rows=4, columns=1}, title='Demo'}}
specs3 = {width=5, name='f3', style=':', color='cyan', symbol='circle-open', size78}

plot(math.sin, '--r') -- plot a function
shownotlegend()
plot(x, y1) -- plot a function defined by x and y1
plot(x, y1, '--xr', x, y2)
plot(x, y1, '--xr', x, y2, ':g', text(0.79, 0.71 - 0.08, 'A'), point(0.79, 0.71, {symbol='circle', size=10, color='blue'}))
plot(x, y1, {xlabel="x-axis", ylabel="y-axis", color='red'})
showlegend()
plot(x, y1, x, y2, specs1, math.sin, '--r')
plot(x, y1, specs1, x, y2, x, y3, 'o')
plot(x, y1, specs3, x, y2, specs2, math.sin, x, y3, specs1)

axisnotsquare()
plot(rand(125, 4)) -- plots functions defined in each column of a matrix with the range of x from 0 to # of rows
plot(rand(125, 4),{layout={width=900, height=400, grid={rows=2, columns=2}, title='Demo'}, names={'f1', 'f2', 'f3', 'g'}})
plot(rand(125, 4), {layout={width=900, height=400, grid={rows=2, columns=2}, title='Example'}})
plot(rand(100,3), {layout={width=900, height=400, grid={rows=3, columns=2}, title='Example'}}, rand(100,2))
plot(rand(100, 2), linspace(1,100,1000), sin(linspace(1,100,1000)), '-og', rand(100, 3))
</code></pre>

<h4>&bull; &nbsp; <a name=plot3d href=#m><code>plot3d(f, xrange, yrange, title, resolution)</code></a></h4>
<p>Plot a surface defined by <code>z = f(x, y)</code>. It is not designed as complicated as <code>plot(...)</code> for 2D graphs. It can only plot one surface at a time.</p>
<p>If <code>f</code> is a function, <code>xrange = {xstart, xstop}</code> and <code>y = {ystart, ystop}</code> define the ranges
for <code>x</code> and <code>y</code> (each default: <code>{-5, 5}</code>), respectively; otherwise, the first 3 arguments are tables of <code>x, y</code>, and <code>z</code> values,
which allows users to set up data and use this function to display a graph. Given that <code>x = {x1, x2, ..., xn}</code> and
<code>y = {y1, y2, ..., yn}</code>, the data passed to <code>plot3(X, Y, Z, title)</code> are as follows:</p>
<code><pre>
X = {{x1, x1, ..., x1}, {x2, x2, ..., x2}, ..., {xn, xn, ..., xn}}
Y = {{y1, y2, ..., yn}, {y1, y2, ..., yn}, ..., {y1, y2, ..., yn}}
Z = {{z11,  ...,  z1n}, {z21,  ...,  z2n}, ..., {zn1,  ...,  zn2}}
</pre></code>
<p>where <code>zij = f(xi, yj)</code>, if a surface is defined by <code>z = f(x, y)</code>.</p>
<p><code>resolution</code>? See <a href=#resol><code>parametriccurve2d</code> and <code>polarcurve2d</code></a>.</p>
<pre><code>require 'mathly'
plot3d(function(x, y) return x^2 - y^2 end) -- saddle

n = 100
x = linspace(0, 2*pi, n)
y = linspace(-pi, pi, n)
X, Y = {}, {}
for i = 1, n do
  X[i] = tt(mathly(1, n, x[i]))
  Y[i] = y
end
function f(x, y) return math.sin(x) * math.cos(y) end
Z = map(f, X, Y)
plot3d(X, Y, Z, 'Demo 2')
</code></pre>

<h4>&bull; &nbsp; <a name=text href=#m><code>text(x, y, txt, style)</code></a></h4>
<p>Return a text object for <code><a href=#plot>plot</a></code> to write a text string <code>txt</code> at the point <code>(x, y)</code> on a graph.</p>
<p><code>style</code> (default: <code>{color='black'}</code>): e.g., <code>{family = 'Arial Black', size = 18, color = '#ff0000'}</code>.</p>
<pre><code>require 'mathly'
x = linspace(-pi, pi, 200)
plot(x, cos(x), point(-pi/3, math.cos(-pi/3)), text(-pi/3, math.cos(-pi/3) - 0.2, 'Point A'), point(pi/3, math.cos(pi/3)), text(pi/3, math.cos(pi/3) - 0.2, 'Point B'))
plot(x, cos(x), text(0, -0.2, 'Demo', {family = 'Sans Serif', size = 28, color = '#00aaff'}))
</code></pre>

<h4>&bull; &nbsp; <a name=circle></a><a name=line></a><a name=parametriccurve2d></a><a name=point></a><a name=polarcurve2d></a><a name=polygon></a><a name=scatter></a><a name=wedge></a>
<a name=arc href=#m><code>arc, circle, line, parametriccurve2d, point, polygon, text, wedge</code></a></h4>
<table><tbody>
<tr><td><code>arc(radius, center, angles, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot an arc of a circle, where <code>angles: {angle1, angle2}</code> (default: <code>{0, 2&pi;}</code>).</td></tr>
<tr><td><code>circle(radius, center, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a circle, where <code>center: {x, y} (default: {0, 0})</code>.</td></tr>
<tr><td><code>line(point1, point2, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a straight line, where <code>point1 = {x1, y1}</code> and <code>point2 = {x2, y2}</code>.</td></tr>
<tr><td><code>parametriccurve2d({x(t), y(t)}, range, style, resolution)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a parametric curve, where <code>x(t)</code> and <code>y(t)</code> are parametric functions, and <code>range = {t1, t2}</code> (default: <code>{-5, 5}</code>) indicating <code>t</code> changes from <code>t1</code> to <code>t2</code>.</td></tr>
<tr><td><code>point(x, y, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a point, where <code>(x, y)</code> are the coordinates of the point. Note: <code>point({{x1, y1}, {x2, y2}}, style)</code> is for plotting multiple points.</td></tr>
<tr><td><code>polarcurve2d(r(&theta;), range, style, resolution)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a polar curve, where <code>r(&theta;)</code> is a polar function, and <code>range = {&theta;1, &theta;2}</code> (default: <code>{0, 2*pi}</code>) indicating <code>&theta;</code> changes from &theta;1 to &theta;2. If <code>r</code> is a number, plot a circle with radius <code>r</code>.</td></tr>
<tr><td><code>polygon(vertices, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a polygon, where <code>vertices = {{x1, y1}, {x2, y2}, ..., {xn, yn}}</code> specifies the coordinates of each vertex in order so that there is an edge connecting any two consecutive vertices. There is an edge connecting <code>{x1, y1}</code> and <code>{xn, yn}</code>.</td></tr>
<tr><td><code>scatter(x, y, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a scatter plot, where <code>x = {x1, x2 ,...}</code> and <code>y = {y1, y2, ...}</code> specify the coordinates of all points <code>{x1, y1}, {x2, y2}, ...</code></td></tr>
<tr><td><code>wedge(radius, center, angles, style)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a wedge of a disk, where <code>angles = {&theta;1, &theta;2}</code> indicating &theta; changes from &theta;1 to &theta;2.</td></tr>
</tbody></table>
<a name=gobjspecs></a>
<p>&#x2713; &nbsp; For most of these graph objects, you may use the following specifications in <code>style</code>.</p>
<table><tbody>
<tr><td><code>'fa'</code></td><td> - </td><td>Fill to the x-Axis</td></tr>
<tr><td><code>'ff'</code></td><td> - </td><td>Fill to to the previous Function</td></tr>
<tr><td><code>'fn'</code></td><td> - </td><td>No filling</td></tr>
<tr><td><code>'fs'</code></td><td> - </td><td>Fill to Self</td></tr>
</tbody></table>
<p>Other specification shortcuts, see <a href=#plotspecs><code>plot</code></a>.</p>
<p>&#x2713; &nbsp; <a name=resol></a>Functions, <code><a href=#parametriccurve2d>parametriccurve2d</a>, <a href=#plot3d>plot3d</a>, <a href=#plotparametriccurve3d>plotparametriccurve3d</a>, <a href=#plotparametricsurface3d>plotparametricsurface3d</a>, <a href=#plotsphericalsurface3d><code>plotsphericalsurface3d</code></a>, and <a href=#polarcurve2d>polarcurve2d</a></code>,
each take a last argument, the minimum <code>resolution</code> (default: 100 for a surface, or 500 for a curve), for users to control the smoothness of a plotted curve or surface if needed.
A larger value means better smoothness and requires more computing time.</p>
<pre><code>require 'mathly'

plot(math.sin, point({{-3, 2}, {2, -1}, {3.2, 2}}), point(-1, 1, {symbol='circle-open', size=18, color='red'}))

x = (0.5 - rr(rand(1, 100))) * 10
plot(scatter(x, cos(x)))
plot(scatter(randi(99,1,200), randi(1000,1,200)))

plot(polygon({{1, 2}, {2, 3}, {5, -1}}),
     polygon({{-1, 2}, {1, 1}, {3, 1}, {0, -1}}, '-rfn'),
     circle(1, {0, 0}, '-fs'),
     point(3, 2, {symbol='circle', size=36, color='red'}),
     circle(1, {1,1}, '-bfn'))

plot(math.sin, '-rfa')

x = linspace(-2.337, 0.779, 100)
X = linspace(-5, 5, 200)
plot(X, cos(X), X, sin(X), '-rff') -- shade regions between two curves
plot(x, cos(x), x, sin(x), '-rff', X, cos(X), X, sin(X)) -- shade part of  ...

axissquare()
plot(
  polarcurve2d(1.5),
  polarcurve2d(function(t) return math.sqrt(t) * math.cos(t) end, {0, 4*pi}, '-b'),
  polarcurve2d(function(x) return math.cos(4*x) end, {0, 2*pi}, '-fs'),
  parametriccurve2d({math.cos, math.sin}, {0, pi/2}, '-gfs')
)

do -- https://en.wikipedia.org/wiki/Butterfly_curve_(transcendental)
  local function f(t) return (exp(cos(t)) - 2*cos(4*t) - sin(t/12)^5) end
  local function x(t) return sin(t) * f(t) end
  local function y(t) return cos(t) * f(t) end
  plot(parametriccurve2d({x, y}, {0, 12*pi}), {layout={title = "Butterfly Curve"}})
end

axisnotsquare()
r = function(t) return math.sin(1.6 * t^2) + math.cos(4 * t)^5 end
plot(polarcurve2d(r, {0, 8*pi}, '-sfn'))
plot(polarcurve2d(r, {0, 8*pi}, '-sfn', 10000)) -- add resolution

gobjs = {}
for i = 1, 6 do
  gobjs[i] = polarcurve2d(function(t) return math.sin(1.6 * t^2) + math.cos(i * t)^5 end, {0, 8*pi}, '-sfn', 10000)
end
plot({layout={width=1900, height=1300, grid={rows=2, columns=3}, title='Example'},
      names={'i=1', 'i=2', 'i=3', 'i=4', 'i=5', 'i=6'}}, table.unpack(gobjs))
</code></pre>

<h4>&bull; &nbsp; <a name=plotparametriccurve3d href=#m><code>plotparametriccurve3d({x(t), y(t), z(t)}, trange, title, resolution)</code></a></h4>
<p>Plot a space curve defined by <code>{x(t), y(t), z(t)}</code>.</p>
<p><code>resolution</code>? See <a href=#resol><code>parametriccurve2d</code> and <code>polarcurve2d</code></a>.</p>
<pre><code>require 'mathly'
plotparametriccurve3d(
  {function(t) return math.cos(t) end,
   function(t) return math.sin(t) end,
   function(t) return t end}, {0,6*pi}, "Helix")

plotparametriccurve3d(
  {function(t) return t*math.cos(t) end,
   function(t) return t*math.sin(t) end,
   function(t) return t end}, {0, 8*pi})
</code></pre>

<h4>&bull; &nbsp; <a name=plotparametricsurface3d href=#m><code>plotparametricsurface3d({x(u, v), y(u, v), z(u,v)}, urange, vrange, title, resolution)</a></code></h4>
<p>Plot a surface defined by <code>x = x(u, v), y = y(u, v), z = z(u,v)</code>.</p>
<p><code>resolution</code>? See <a href=#resol><code>parametriccurve2d</code> and <code>polarcurve2d</code></a>.</p>
<pre><code>require 'mathly'
plotparametricsurface3d(
  {function(u,v) return u end,
   function(u,v) return v end,
   function(u,v) return math.sqrt(u^2 + v^2) end}, {-3, 3}, {-3, 3}, 'Demo')

plotparametricsurface3d(
  {function(u,v) return 2*math.sin(u)*math.cos(v) end,
   function(u,v) return 2*math.sin(u)*math.sin(v) end,
   function(u,v) return 2*math.cos(v) end}, {0, pi}, {0, 2*pi})

do -- https://plotly.com/python/3d-surface-plots/
  local a, b, d = 1.32, 1, 0.8
  local c = a^2 - b^2
  local u, v = linspace(0, 2*pi, 100), linspace(0, 2*pi, 100)
  local function x(u, v) return (d * (c - a * cos(u) * cos(v)) + b^2 * cos(u)) / (a - c * cos(u) * cos(v)) end
  local function y(u, v) return b * sin(u) * (a - d*cos(v)) / (a - c * cos(u) * cos(v)) end
  local function z(u, v) return b * sin(v) * (c*cos(u) - d) / (a - c * cos(u) * cos(v)) end
  plotparametricsurface3d({x, y, z}, {0, 2*pi}, {0, 2*pi})
end
</code></pre>

<h4>&bull; &nbsp; <a name=showlegend></a><a name=shownotlegend></a><a name=shownotyaxis></a><a name=showyaxis></a><a name=shownotxaxis></a><a name=showxaxis></a><a name=axissquare></a><a name=axisnotsquare></a><a name=showaxes></a><a name=shownotaxes></a><a name=showgridlines></a><a name=shownotgridlines></a><a href=#m><code>axissquare, axisnotsquare; showaxes, shownotaxes ...</code></a></h4>
<table><tbody>
<tr><td><code>axissquare(),    axisnotsquare()</code></td><td> &nbsp; </td><td>Force or stop a square axis aspect ratio (default: not square)</td></tr>
<tr><td><code>showaxes(),      shownotaxes()</code></td><td> &nbsp; </td><td>Show/hide axes (all default: show)</td></tr>
<tr><td><code>showxaxis(),     shownotxaxis()</code></td><td> &nbsp; </td><td>Show/hide the <code>x</code>-axis</td></tr>
<tr><td><code>showyaxis(),     shownotyaxis()</code></td><td> &nbsp; </td><td>Show/hide the <code>y</code>-axis</td></tr>
<tr><td><code>showgridlines(), shownotgridlines()</code></td><td> &nbsp; </td><td>Show/hide gridlines</td></tr>
<tr><td><code>showlegend(),    shownotlegend()</code></td><td> &nbsp; </td><td>Show/hide the legend</td></tr>
</tbody></table>
<p>&#x2713; &nbsp; These functions are not valid for 3D graphs.</p>

<h4>&bull; &nbsp; <a name=boxplot></a><a name=pareto></a><a name=freqpolygon></a><a name=histfreqpolygon></a><a name=hist></a><a name=hist1></a>
<a name=pie href=#m><code>freqpolygon, hist, hist1, histfreqpolygon, pareto, pie</code></a></h4>
<table><tbody>
<tr><td><code>boxplot(x, names)</code></td><td> </td><td>Return a special graph object for <code><a href=#plot>plot</a></code> to plot a box (or box-and-whisker) plot, where <code>x</code> is a table or a matrix of numbers. <code>names = {'name1', 'name2', ...}</code> is optional. If <code>x</code> is a matrix or a table of tables/rows, each row is a data set and thus has a box plot.</td></tr>
<tr><td><code>freqpolygon(x, nbins, style, xrange)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a frequency polygon.</td></tr>
<tr><td><code>hist(x, nbins, style, xrange)</code></td><td> </td><td>Return a special graph object for <code><a href=#plot>plot</a></code> to plot a histogram. If <code>x</code> is a matrix or a table of tables/rows, each row is a data set and each bin of the histogram contains one bar per row of the matrix.</td></tr>
<tr><td><code>hist1(x, nbins, style, xrange)</code></td><td> </td><td>Return an ordinary graph object for <code><a href=#plot>plot</a></code> to plot a histogram.</td></tr>
<tr><td><code>histfreqpolygon(x, nbins, style, xrange, style1)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a histogram plus a frequency polygon, where <code>style</code> defines the style of the histogram while <code>style1</code> specifies the style of the frequency polygon.</td></tr>
<tr><td><code>pareto(data, style, style1)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a pareto chart.</td></tr>
<tr><td><code>pie(x, nbins, radius, style, offcenter, names)</code></td><td> </td><td>Return a graph object for <code><a href=#plot>plot</a></code> to plot a pie chart, where <code>radius</code> is the radius of the pie disk (default: 1), and <code>offcenter</code> specifies which wedges are away from the center by given distances (default: 0). Note: <code>pie({bins = {freq1, freq2, ...}}...)</code> is for plotting a pie chart for bins with frequences <code>freq1, freq2, ..., in order</code>, and <code>names = {'name1', 'name2', ...}</code> can be given in this situation.</td></tr>
</tbody></table>
<p>With this group of functions,</p>
<table><tbody>
<tr><td><code>x</code></td><td> &nbsp; </td><td>The data, a table of numbers</td></tr>
<tr><td><code>nbins</code></td><td> &nbsp; </td><td>The number of bins (default: 10)</td></tr>
<tr><td><code>style</code></td><td> &nbsp; </td><td>E.g., <code>'-r', '-rfs'. </code>See also: <a href=#gobjspecs><code>'fa', 'ff', 'fn', 'fs'</code></a></td></tr>
<tr><td><code>xrange</code></td><td> &nbsp; </td><td>In the format <code>{xmin, xmax}</code>, specifying the range of data values in <code>x</code>. If not provided, it is determined by the lowest and largest values in <code>x</code>.</td></tr>
</tbody></table>
<p>See also: <a href=#arc><code>arc, circle, line, parametriccurve2d, point, polygon, wedge</code></a></p>
<p><a name=namedargs><b>Named arguments for this group of functions:</b></p>
<p>To make it easier to use this group of functions, if necessary or if convenient, each function may be called in two more ways, <code>pie({...})</code> or <code>pie{...}</code>. There are rules to follow: 1) We may not use names at all; 2) We use names for all arguments; 3) Arguments without names must be the first ones and in defined order. Take <code>pie</code> as an example,</p>
<pre><code>require 'mathly'

data = {1, 11, 4, 7, 6, 5, 10, 4, 3, 15, 13, 1, 4, 10, 9}
axissquare()
-- don't want to use named variables? call a function in an ordinary way: pie(x, nbins, radius, style, offcenter, names)
plot(pie(data))
plot(pie(data, 5, nil, '-g')) -- nil? the default value (of radius = 1) is used
plot(pie(data, 5, nil, '-gfs'))
plot(pie(data, 5, nil, nil, 0.1)) -- the same as the following one; offcenter = 0.1, each bin is away from the center by 0.1
plot(pie{data, 5, nil, nil, 0.1}) -- pie{...} or pie({...}) is allowed but not recommended
-- in the above examples, there are no named arguments. pie({...}), pie{...}, and pie(...) are the same, but the first two ways are not recommended.

-- when there are named variables, we must call a function in a special way: pie({...}) or pie{...}.
plot(pie{nbins = 7, x = data}) -- the order of named arguments doesn't matter

-- named and unnamed variables: unnamed ones are placed before named ones and in specified order
plot(pie{data, 7, offcenter = {{2, 0.1}, {5, 0.2}}, style = '-fs'}) -- offcenter = {{2, 0.1}, {5, 0.2}}, the 2nd & 5th bins are away from the center by ...
plot(pie{x = {bins = {0.0930, 0.1163, 0.0233, 0.2791, 0.1395, 0.3488}}, style='-', offcenter = {{3, 0.6}, {5, 0.1}, {1, 0.15}}})
</code></pre>

<p>More examples,</p>
<pre><code>require 'mathly'

data1 = {1, 2, 3, 4, 2, 12, 3, 4, 2, 12, 9, 9, 9, 8, 5, 3, 3, 2, 1, 5, 3, 2}
data2 = {2, 1, 2, 4, 5, 7, 11}
data3 = {3, 2, 3, 4, 2, 2, 9, 11}
plot(boxplot(data1))
plot(boxplot({data1, data2}, {"name 1", "name 2"}))
plot(boxplot({data1, data2, data3, {2, 3, 5, 7, 11, 20, 1, 2, 3}}))

mu, sigma = 72.11, 13.36
x = flatten(randn(1, 5000, mu, sigma))

function n(x, mu, sigma)
  local z = (x - mu) / sigma
  return math.exp(-0.5 * z^2) / (math.sqrt(2 * pi) * sigma)
end

X = linspace(mu - 4 * sigma, mu + 4 * sigma, 5000)
Y = map(function(x) return n(x, mu, sigma) * 7.8 end, X)

gobj = hist1(x, 12)
axisnotsquare(); shownotlegend()
plot(gobj, X, Y, '--r')
plot(freqpolygon(x))
plot(freqpolygon{x, style='--r*'})
plot(histfreqpolygon(x))
plot(histfreqpolygon{x, style='-bfs', style1='--r*'})

x = {{'Apple', 382}, {'Orange', 22}, {'Pearl', 91}, {'Peach', 53}, {'Banana', 19}, {'Strawberry', 35}}
plot(pareto(x))
plot(pareto(x, '-bfs'))
plot(pareto(x, nil, '--gx'))  -- "yaxis2":{"tickformat":".0%", "overlaying": 'y', "side": 'right' }

showaxes()
plot(hist(randn(1, 100)))

A = randi({0, 99}, 3, 50)
plot(hist(A)) -- nil? the default value will be used
plot(hist{A, xrange = {0, 99}}) -- run multiple times, the two can produce different results
</code></pre>
<p></p>
<hr>
<h2 style="margin-left: 20px;">Note</h2>
<ol>
<li>Part of modules <a href=http://dkolf.de/dkjson-lua>dkjson.lua</a> and <a href=https://github.com/kenloen/plotly.lua>plotly.lua</a>
is merged into this project to reduce dependencies and make it easier for users to download and use mathly. Though
some changes have been made, full credit belongs to the original authors for whom the author of mathly
is very grateful.</li>
<p></p>
<li>This project was started first right in the downloaded code of the Lua module,
<a href="https://github.com/davidm/lua-matrix/blob/master/lua/matrix.lua">matrix.lua</a>, to see if Lua is good
for numerical computing. However, it failed to solve numerically a boundary value problem. The solution
was obviously wrong because the boundary condition at one endpoint is not satisfied, but I could not find
anything wrong in both the algorithm and the code. I had to wonder if there were bugs in the module. In many
cases, it is easier to start a small project from scratch than using and debugging others' code. In
addition, matrix.lua addresses a column vector like a[i][1] and a row vector a[1][i], rather than a[i]
in both cases, which is quite ugly and unnatural. Furthermore, basic plotting utility is not provided in
matrix.lua. Therefore, this mathly module was developed. But anyway, I appreciate the work in matrix.lua.
Actually, you may find some similarities in the code of matrix.lua and mathly.lua, e.g., m1, m2 are used
to name arguments of some functions.</li>
</ol>
<p style="margin-left: 40px;">December 25, 2024</p>
</div>
</body>
</html>
